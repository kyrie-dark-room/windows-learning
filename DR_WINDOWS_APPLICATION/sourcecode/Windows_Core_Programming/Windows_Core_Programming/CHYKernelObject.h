#pragma once
/*
* 知识：
*	1）系统会创建和处理几种类型的内核对象，比如访问令牌（access token）对象、事件对象、文件对象、文件映射对象、I/O完成端口对象、作业对象、
      邮件槽（mailslot）对象、互斥量（mutex）对象、管道（pipe）对象、进程对象、信号量（semaphore）对象、线程对象、可等待的计时器（waitable timer）对象
	  以及线程池工厂（thread pool worker factory）对象等。
*	2）利用Sysinternals的免费工具WinObj，可以查看一个包含所有内核对象类型的列表。
*	3）每个内核对象都只是一个内存块，它由操作系统内核分配，并只能由操作系统内核访问。这个内存块是一个数据结构，其成员维护着与对象相关的信息。少数成员（安全描述符和使用计数等）
*     是所有对象都有的，但其他大多数成员都是不同类型的对象特有的。
*	4）句柄（handle）：它标识了所创建的对象。可以将这个句柄想象为一个不透明（opaque）的值，它可由进程中的任何线程使用。在32位Windows进程中，句柄是一个32位值；在64位Windows
*     进程中，则是一个64位值。为了增强操作系统的可靠性，这些句柄值是与进程相关的。
*	5）内核对象的所有者是操作系统，而非进程。
*	6）操作系统内核知道当前多少个进程正在使用一个特定的内核对象，因为每个对象都包含一个使用计数（usage count）。使用计数是所有内核对象类型都有的一个数据成员。
*	7）内核对象可以用一个安全描述符（security descriptor，SD）来保护。安全描述符描述了谁（通常是对象的创建者）拥有对象；哪些组和用户被允许访问或使用此对象；
      哪些组和用户被拒绝访问此对象。
*	8）要想判断一个对象是不是内核对象，最简单的方式是查看创建这个对象的函数。几乎所有创建内核对象的函数都有一个允许我们指定安全属性信息的参数。
*	9）一个进程在初始化时，系统将为它分配一个句柄表（handle table）。这个句柄表仅供内核对象使用，不适用于用户对象和GDI对象。
*													进程的句柄表的结构
*      ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
*        索引 |    指向内核对象内存块的指针    |    访问掩码（包含标志位的一个DWORD）    |    标志
*	   ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
*         1   | 0x????????                     |    0x????????							 |    0x???????? 
*	   ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
*         2   | 0x????????                     |    0x????????							 |    0x???????? 
*      ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
*         ... | ...                            |    ...							         |    ...
*      ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
*	10）
*/

namespace HY_KERNELOBJECT
{
	class CHYKernelObject
	{

	};
}

