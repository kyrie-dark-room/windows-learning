#pragma once
/*
* 知识：
*	1）系统会创建和处理几种类型的内核对象，比如访问令牌（access token）对象、事件对象、文件对象、文件映射对象、I/O完成端口对象、作业对象、
      邮件槽（mailslot）对象、互斥量（mutex）对象、管道（pipe）对象、进程对象、信号量（semaphore）对象、线程对象、可等待的计时器（waitable timer）对象
	  以及线程池工厂（thread pool worker factory）对象等。
*	2）利用Sysinternals的免费工具WinObj，可以查看一个包含所有内核对象类型的列表。
*	3）每个内核对象都只是一个内存块，它由操作系统内核分配，并只能由操作系统内核访问。这个内存块是一个数据结构，其成员维护着与对象相关的信息。少数成员（安全描述符和使用计数等）
*     是所有对象都有的，但其他大多数成员都是不同类型的对象特有的。
*	4）句柄（handle）：它标识了所创建的对象。可以将这个句柄想象为一个不透明（opaque）的值，它可由进程中的任何线程使用。在32位Windows进程中，句柄是一个32位值；在64位Windows
*     进程中，则是一个64位值。为了增强操作系统的可靠性，这些句柄值是与进程相关的。
*	5）内核对象的所有者是操作系统，而非进程。
*	6）操作系统内核知道当前多少个进程正在使用一个特定的内核对象，因为每个对象都包含一个使用计数（usage count）。使用计数是所有内核对象类型都有的一个数据成员。
*	7）内核对象可以用一个安全描述符（security descriptor，SD）来保护。安全描述符描述了谁（通常是对象的创建者）拥有对象；哪些组和用户被允许访问或使用此对象；
      哪些组和用户被拒绝访问此对象。
*	8）要想判断一个对象是不是内核对象，最简单的方式是查看创建这个对象的函数。几乎所有创建内核对象的函数都有一个允许我们指定安全属性信息的参数。
*	9）一个进程在初始化时，系统将为它分配一个句柄表（handle table）。这个句柄表仅供内核对象使用，不适用于用户对象和GDI对象。
*													进程的句柄表的结构
*      ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
*        索引 |    指向内核对象内存块的指针    |    访问掩码（包含标志位的一个DWORD）    |    标志
*	   ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
*         1   | 0x????????                     |    0x????????							 |    0x???????? 
*	   ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
*         2   | 0x????????                     |    0x????????							 |    0x???????? 
*      ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
*         ... | ...                            |    ...							         |    ...
*      ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
*	10）内核对象的内容被保存在内核地址空间中--系统上运行的所有进程都共享这个空间。对于32位系统，这是0x80000000到0xFFFFFFFF之间的内存空间。对于64位系统，则是0x00000400'00000000
*     到0xFFFFFFFF'FFFFFFFF之间的内存空间。
*	11）我们有时可能想控制哪些子进程能继承内核对象句柄。可以调用SetHandleInformation函数来改变内核对象句柄的继承标志。
*	12）Microsoft没有提供任何专门的机制来保证我们创建独一无二的对象名。为了确保名称的唯一性，我的建议是创建一个GUID，并将这个GUID的字符串形式作为自己的对象名称使用。
*	13）如果我们必须知道我们的进程在哪个Terminal Services会话中运行，可以借助于ProcessIdToSessionId函数。
*	14）一个服务的命名内核对象始终位于全局命名空间内的。默认情况下，在终端服务中，应用程序自己的命名内核对象在会话的命名空间内。不过，我们也可以强制把一个命名对象放入
*     全局命名空间，具体做法是在其名称前加上“Global\”前缀，也可以显式指出我们希望把一个内核对象放入当前会话的命名空间，具体做法是在名称前加上“Local\”前缀，Microsoft
*     认为Global和Local是保留关键字，所以除非为了强制一个特定的命名空间，否则不应该在对象名称中使用它们。Microsoft还认为Session是保留关键字。
*   15）如果想确保我们的应用程序创建的内核对象名称永远不会和其他应用程序的名称冲突，或者想确保它们免遭劫持，可以定义一个自定义的前缀，并把它作为自己的专有命名空间使用，
*     这和使用Global和Local前缀是相似的。负责创建内核对象的服务器进程将定义一个边界描述法（boundary descriptor），以对命名空间的名称自身进行保护。
*/

#include <Windows.h>

namespace HY_KERNELOBJECT
{
	class CHYKernelObject
	{
	public:
		virtual BOOL CreatePrivateNamespace() = 0;
	};
}

