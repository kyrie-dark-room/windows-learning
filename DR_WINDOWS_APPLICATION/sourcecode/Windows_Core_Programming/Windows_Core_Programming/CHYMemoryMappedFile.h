#pragma once
#include "CHYMemoryObject.h"

/*
* 知识点：
* 1）内存映射文件：与虚拟内存相似，内存映射文件允许开发人员预订一块地址空间区域并给区域调拨物理存储器。不同之处在于，内存映射文件的物理存储器来自磁盘上已有的文件，而不是来自系统
*   的页交换文件。一旦把文件映射到地址空间，我们就可以对它进行访问，就好像整个文件都已经被载入内存一样。
* 2）内存映射文件主要用于以下三种情况。
*     ・系统使用内存映射文件来载入并运行.exe和动态链接库（DLL）文件。这大量节省了页交换文件的空间以及应用程序启动的时间。
*	  ・开发人员可以用内存映射文件来访问磁盘上的数据文件。这使得我们可以避免直接对文件进行I/O操作和对文件内容进行缓存。
*	  ・通过使用内存映射文件，我们可以在同一台机器的不同进程之间共享数据。Windows的确提供了其他一些方法来在进程间传送数据，但这些方法都是通过内存映射文件来实现的。因此，如果要在
*   同一台机器的不同进程之间共享数据，内存映射文件是最高效的方法。
* 3）当一个线程在调用CreateProcess的时候，系统会执行以下步骤。
*		（1）系统会先确定CreateProcess所指定的可执行文件所在的位置。如果无法找到该.exe文件，那么系统将不会创建进程，这时CreateProcess会返回FALSE。
*		（2）系统创建一个新的进程内核对象。
*		（3）系统为新进程创建一个私有地址空间。
*		（4）系统预订一块足够大的地址空间来容纳.exe文件。待预订的地址空间区域的具体位置已经在.exe文件中指定。默认情况下，.exe文件的基地址是0x00400000。（对运行在64位Windows下的64
*           位应用程序来说，这个地址可能会有所不同。）但是，只需在构建应用程序的.exe文件时使用/BASE链接器开关，我们就可以给自己的应用程序指定一个不同的地址。
*		（5）系统会对地址空间区域进行标注，表明该区域的后备物理存储器来自磁盘上的.exe文件，而并非来自系统的页交换文件。
*    当系统把.exe文件映射到进程的地址空间之后，会访问.exe文件中的一个段，这个段列出了一些DLL文件，它们包含该.exe文件调用到的函数。然后系统会调用LoadLibrary来载入每个DLL，如果哪个
*   DLL需要用到其他DLL，那么系统同样会调用LoadLibrary来载入相应的DLL。系统每次调用LoadLibrary来载入一个DLL的时候，执行的操作与刚才列出的第4不和第5步相似。
*		（1）系统会预定一块足够大的地址空间区域来容纳DLL文件。待预订的地址空间区域的具体位置已经在DLL文件中指定。默认情况下，Microsoft链接器将x86平台的DLL的基地址设为0x10000000，
*           将x64平台的DLL的基地址设为0x00400000。但是，只需在构建DLL文件时使用/BASE链接器开关，我们就可以指定一个不同的基地址。所有与Windows一起发布的系统DLL都有不同的基地址，
*			这样即使把它们载入到同一个地址空间，也不会发生重叠。
*		（2）如果系统无法在DLL文件指定的基地址处预订区域，这可能是因为该区域已经被另一个DLL或.exe占用，也可能是因为区域不够大，这时系统会尝试在另一个地址来为DLL预订地址空间区域。
*			如果系统无法将DLL载入到指定的基地址，那么这种情况就不太走运了。这有两个原因。首先，如果DLL不包含重定位信息，那么系统将无法载入DLL。（当使用链接器的/FIXED开关来构建
*			DLL时，可以从DLL中去除重定位信息。这可以使DLL文件变得更小，但这意味着DLL“必须”被载入到指定的基地址，否则的话它将无法被载入。）其次，系统必须对DLL执行重定位操作。
*			重定位不仅需要占用页交换文件中额外的存储空间，而且会增加载入DLL所需的时间。
*		（3）系统会对地址空间区域进行标注，表明该区域的后备物理存储器来自磁盘上的DLL文件，而并非来自系统的页交换文件。如果由于Windows不能将DLL载入到指定的基地址而必须执行重定位
*			的话，那么系统还会另外进行标注，表明DLL中有一部分物理存储器被映射到了页交换文件。
*	 把所有的.exe和DLL文件都映射到进程的地址空间之后，系统会开始执行.exe文件启动代码。当完成对.exe文件的映射后，系统会负责所有的换页（paging）、缓存（buffering）、以及高速缓存（caching）
*   操作。例如，如果.exe文件中的代码跳转到一个指定地址，但该地址尚未载入内存，那么会引发一个页面错误（page fault）。系统会检测到这个错误并自动将该页代码从文件映像载入到内存中。
*   然后系统会把该内存页映射到进程地址空间中的适当位置，并将线程继续执行，就好像该页代码早已载入内存一样。当然，这一切对应用程序来说都是透明的。每当线程试图访问尚未载入内存的代码
*   或数据时，系统都会重复这一过程。
* 4）实际上，文件的内容被分为段。代码在一个段中，而全局变量在另一个段中。段是对齐到页面大小的整数倍。应用程序可以通过调用GetSystemInfo来检测页面大小。在.exe或DLL文件中，代码段通常
*   在数据段的前面。
* 5）如果应用程序的一个实例修改了数据页面中的一些全局变量，那么应用程序所有实例的内存都会被修改。由于这种类型的修改可能会导致灾难性的结果，因此必须避免。系统通过内存管理系统的写时
*   复制（copy-on-write）特性来防止这种情况的发生。任何时候当应用程序试图写入内存映射文件的时候，系统会首先截获此类尝试，接着为应用程序试图写入的内存页面分配一块新的内存，然后复制
*   页面内容，最后让应用程序写入到刚分配的内存块。最终的结果就是，应用程序的其他实例不会受到任何影响。
* 6）当系统创建一个进程时，会检查文件映像的的所有页面。对那些通常需要用写时复制属性进行保护的页面，系统会立即从页交换文件中调拨存储器。但系统只是调拨这些页面，而不会实际载入页面的内容。
*   当程序访问到文件映像中的一个页面时，系统会载入相应的页面。如果该页从未修改过，那么可以舍弃其中的内容并在需要时重新载入。但如果文件影像的该页面被修改过，那么系统必须把修改过的页面
*   调换到页交换文件中。
* 7）讨论一项可以在同一个.exe文件或DLL的多个实例之间共享变量的技术。
*     每个.exe文件或DLL文件映像由许多段组成。按照惯例，每个标准的段名都以点号开始。例如，在编译程序的时候，编译器会将代码放在一个名叫.text的段中。此外，编译器还会将未初始化的数据放在.bss段
*   中，将已初始化的数据放在.data段中。
*     每个段都有一些与之相关联的属性，如表所示：
*     ---------------------------------------------------------------------------------------
*       属 性  |								含  义
*	  ---------------------------------------------------------------------------------------
*      READ	   | 可以从该段读取数据
*	  ---------------------------------------------------------------------------------------
*      WRITE   | 可以向该段写入数据
*	  ---------------------------------------------------------------------------------------
*      EXECUTE | 可以执行该段的内容
*	  ---------------------------------------------------------------------------------------
*      SHARED  | 该段的内容为多个实例所共享（这个属性事实上关闭了写入复制机制）
*     ---------------------------------------------------------------------------------------
*     我们可以用Microsoft Visual Studio的DumpBin工具（需指定/Headers开关）来查看.exe或DLL映像文件中的各个段。
*     可执行文件的常用段
*	  ---------------------------------------------------------------------------------------
*       段  名  |							目  的
*	  ---------------------------------------------------------------------------------------
*       .bss	| 未经初始化的数据
*	  ---------------------------------------------------------------------------------------
*       .CRT	| 只读的C运行时数据
*	  ---------------------------------------------------------------------------------------
*       .data	| 已初始化的数据
*	  ---------------------------------------------------------------------------------------
*		.debug	| 调试信息
*	  ---------------------------------------------------------------------------------------
*		.didata	| 延迟导入的名字表（Delay imported names table）
*	  ---------------------------------------------------------------------------------------
*		.edata	| 导出的名字表（Exported names table）
*	  ---------------------------------------------------------------------------------------
*		.idata	| 导入的名字表（Imported names table）
*     ---------------------------------------------------------------------------------------
*		.rdata	| 只读的运行时数据
*	  ---------------------------------------------------------------------------------------
*		.reloc	| 重定位表信息
*	  ---------------------------------------------------------------------------------------
*		.rsrc	| 资源
*	  ---------------------------------------------------------------------------------------
*		.text	| .exe文件或DLL的代码
*     ---------------------------------------------------------------------------------------
*		.textbss| 当启用增量链接（Incremental Linking）选项时，由C++编译器生成
*	  ---------------------------------------------------------------------------------------
*		.tls	| 线程本地存储（Thread-local storage）
*	  ---------------------------------------------------------------------------------------
*		.xdata	| 异常处理表
*	  ---------------------------------------------------------------------------------------
*     除了使用编译器和链接器所创建的标准段之外，我们还可以在编译的时候使用下面的编译器指示符来创建自己的段：
*         #pragma data_seg("sectionname")
*       示例：
*         #pragma data_seg("Shared")
*         LONG g_lInstanceCount = 0;
*         #pragma data_seg()
*       需要谨记的极其重要的一点是：编译器只会将已初始化的变量保存在这个段中。如果我们去掉初始化的部分，那么编译器就会将该变量放到Shared段以为的其他段中。
*       但是，Microsoft Visual C++编译器确实提供了一个allocate声明符（declaration specifier），它允许我们将未经初始化的数据放到任何我们想要放的段中。
*         __declspec(allocate("Shared")) int d;
*     之所以要将变量放到一个单独的段中，最常见的原因也许就是为了在同一个.exe或DLL的多个实例间共享变量。
*       为了共享变量，仅仅告诉编译器把变量放到单独的段中是不够的。我们还必须告诉链接器要共享这个段中的变量。这可以通过在链接器的命令行中使用/SECTION开关来实现：
*         /SECTION:name, attributes(RWES)
*       我们也可以用下面的写法，直接把链接器开关嵌入到源代码中：
*		  #pragma comment(linker, "/SECTION:Shared,RWS")
*         这行代码告诉编译器把其中的字符串嵌入到所生成的.obj文件中的一个特殊的段中，这个段名叫“.drectve”。当链接器把所有的.obj模块合并到一起的时候，链接器会检查每个.obj
*           模块的“.drectve”段，并将所有的字符串当作是传给链接器的命令行参数。
*       虽然我们可以创建共享段，但Microsoft并不鼓励使用共享段。这出于两个原因。
*         首先，以这种方式共享内存可能会导致潜在的安全漏洞。
*         其次，共享变量意味着一个应用程序中的错误可能会影响到另一个应用程序，因为没有任何方法能够保护共享变量，使它们不会被错误地改写。
* 8）映射到内存的数据文件：Windows操作系统使我们能够把数据文件映射到进程的地址空间中，这样一来，对大型数据流进行操控就非常容易。
* 9）使用内存映射文件
      要使用内存映射文件，需要执行下面三个步骤：
*	  （1）创建或打开一个文件内核对象，该对象标识了我们想要用作内存映射文件的那个磁盘文件。
*	  （2）创建一个文件映射内核对象（file-mapping kernel object）来告诉系统文件的大小以及我们打算如何访问文件。
*	  （3）告诉系统把文件映射对象的部分或全部映射到进程的地址空间中。
*	  用完内存映射文件之后，必须执行下面三个步骤来做清理工作：
*	  （1）告诉系统从进程地址空间中取消对文件映射内核对象的映射。
*	  （2）关闭文件映射内核对象。
*	  （3）关闭文件内核对象。
* 10）如何将一个16EB的文件映射到一个较小的地址空间中。好吧，这实际上是不可能的，不过有另一种方法可以达到类似的效果。这种方法就是只映射文件的一个视图，而这个视图只包含
*	 文件的一小部分数据。一开始，我们应该把文件开头的部分映射到视图中。完成对文件的第一个视图的访问后，我们可以撤销对文件这一部分的映射，然后把文件的另一部分映射到视图中。
*	 我们一直重复这个过程，直到完成对整个文件的访问。
* 11）系统允许我们把同一个文件的数据映射到多个视图中。Windows允许我们以同一个数据文件为后备存储器来创建多个文件映射对象。Windows并不保证这些不同的文件映射对象的各个视图
	 是一致的。系统只保证在同一文件映射对象的多个视图间保持一致。
* 12）Windows提供了多种机制，使得应用程序之间能够快速、方便地共享数据和信息。一直以来Windows在这方面做的都很不错。这些机制包括RPC、COM、OLE、DDE、Windows消息（尤其是WM_COPYDATA）、
*	 剪贴板、邮件槽（mailslot）、管道(pipe)、套接字(socket)等。在Windows中，在同一台机器上共享数据的最底层的机制就是内存映射文件。没错，如果在同一台机器上的多个进程间进行
*	 通信的话，那么刚才提到的所有机制归根结底都会用到内存映射文件。如果要求低开销和高性能，内存映射文件无疑是最好的选择。
* 13）同所有内核对象一样，我们可以通过三种技术来跨进程共享对象：句柄继承、命名和句柄复制。
*/

namespace HY_MEMORYOBJECT
{
	class CHYMemoryMappedFile : public CHYMemoryObject
	{
	public:
		CHYMemoryMappedFile(void);
		~CHYMemoryMappedFile(void);

		// 通过调用CreateFile函数来创建或打开一个文件内核对象
		HANDLE CreateFile(
			LPCWSTR pszFileName,
			DWORD dwDesiredAccess, 
			DWORD dwShareMode, 
			PSECURITY_ATTRIBUTES psa, 
			DWORD dwCreationDisposition, 
			DWORD dwFlagsAndAttributes, 
			HANDLE hTemplateFile);

		// 创建文件映射内核对象，我们必须告诉系统文件映射对象需要多大的物理存储器，为了达到这一目的
		HANDLE CreateFileMapping(HANDLE hFile, PSECURITY_ATTRIBUTES psa, DWORD fdwProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, PCTSTR pszName);
		HANDLE CreateFileMappingNuma(HANDLE hFile, PSECURITY_ATTRIBUTES psa, DWORD fdwProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, PCTSTR pszName, DWORD dwPreferredNumaNode);

		// 将文件的数据映射到进程的地址空间，在创建了文件映射对象之后，还需要为文件的数据预定一块地址空间区域并将文件的数据作为物理存储器调拨给区域
		PVOID MapViewOfFile(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap);
		PVOID MapViewOfFileExNuma(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, 
			LPVOID lpBaseAddress, DWORD dwPreferredNumaNode);
		
		// 建议系统把文件映射到指定的地址
		PVOID MapViewOfFileEx(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, PVOID pvBaseAddress);
		
		// 不再需要把文件的数据映射到进程的地址空间中时，可以调用下面的函数来释放内存区域：
		BOOL UnmapViewOfFile(PVOID pvBaseAddress);

		// 处于速度上的考虑，系统会对文件数据的页面进行缓存处理，这样在处理文件映射视图的时候就不需要随时更新磁盘上的文件。如果需要确保所做的修改已经被写入到磁盘中，那么可以调用
		BOOL FlushViewOfFile(PVOID pvAddress, SIZE_T dwNumberOfBytesToFlush);

		// 关闭文件映射对象和文件对象
		BOOL CloseHandle(HANDLE hObject);

	private:
		CHYMemoryMappedFile(const CHYMemoryMappedFile&) = delete;
		CHYMemoryMappedFile& operator=(const CHYMemoryMappedFile&) = delete;
		CHYMemoryMappedFile(CHYMemoryMappedFile&&) = delete;
		CHYMemoryMappedFile& operator=(CHYMemoryMappedFile&&) = delete;
	};
}

