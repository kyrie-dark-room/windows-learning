#pragma once

/*
* 知识：
* 1）进程的虚拟地址空间：
*    每个进程都有自己的虚拟地址空间。对32位进程来说，这个地址空间的大小为4GB，这是因为32位指针可以表示从0x00000000到0xFFFFFFFF之间的任一值。指针在这个范围内可以有4294967296个值，它们
*   覆盖了进程的4GB地址空间。对64位进程来说，由于64位指针可以表示从0x00000000'00000000到0xFFFFFFFF'FFFFFFFF之间的任一值，因此这个地址空间的大小为16EB。指针在这个范围内可以有
    18446744073709551616个值，它们覆盖了进程的16EB地址空间。这个地址空间实在是太大了。
* 2）在Windows中，正在运行的线程看不到属于操作系统本身的内存，这意味着它不能无意间访问到操作系统的数据。
* 3）每个进程的虚拟地址空间被划分为许多分区（partition）。由于地址空间的分区依赖于操作系统的底层实现，因此会随着Windows内核的不同而略有变化。我们可以看到，32位Windows内核和64位Windows
*   内核的分区基本一致，唯一的不同在于分区的大小和分区的位置。下面我们来看一下系统如何使用每一个分区。
*                                                                   进程的地址空间是如何划分的
*   ---------------------------------------------------------------------------------------------------------------------------------------------------------------------
*       分   区       |       x86 32位 Windows     |       3GB用户模式下的x86 32位Windows        |        x64 64位Windows      |       IA-64 64位Windows
*   ---------------------------------------------------------------------------------------------------------------------------------------------------------------------
*     空指针赋值分区  |  0x00000000~0x0000FFFF     |           0x00000000~0x0000FFFF             |     0x00000000'00000000     |    0x00000000'00000000
*                     |                            |                                             |     0x00000000'0000FFFF     |    0x00000000'0000FFFF
*   ---------------------------------------------------------------------------------------------------------------------------------------------------------------------
*     用户模式分区    |  0x00010000~0x7FFEFFFF     |           0x00010000~0xBFFEFFFF             |     0x00000000'00010000     |    0x00000000'00010000
*                     |                            |                                             |     0x000007FF'FFFEFFFF     |    0x000006FB'FFFEFFFF
*   ---------------------------------------------------------------------------------------------------------------------------------------------------------------------
*     64KB禁入分区    |  0x7FFF0000~0x7FFFFFFF     |           0xBFFF0000~0xBFFFFFFF             |     0x000007FF'FFFF0000     |    0x000006FB'FFFF0000
*                     |                            |                                             |     0x000007FF'FFFFFFFF     |    0x000006FB'FFFFFFFF
*   ---------------------------------------------------------------------------------------------------------------------------------------------------------------------
*     内核模式分区    |  0x80000000~0xFFFFFFFF     |           0xC0000000~0xFFFFFFFF             |     0x00000800'00000000     |    0x000006FC'00000000
*                     |                            |                                             |     0xFFFFFFFF'0xFFFFFFFF   |    0xFFFFFFFF'FFFFFFFF
*   ---------------------------------------------------------------------------------------------------------------------------------------------------------------------
* 4）空指针赋值分区：保留该分区的目的是为了帮助程序员捕获对空指针的赋值。如果进程中的线程试图读取或写入位于这一分区内的内存地址，就会引发访问违规。
* 5）用户模式分区
*   这一分区是进程地址空间的驻地。可用的地址空间和用户模式分区的大小取决于CPU体系结构。
*   -----------------------------------------------------------------------------------
*     CPU体系结构   |       用户模式分区的可用地址空间        |   用户模式分区的大小
*   -----------------------------------------------------------------------------------
*     x86(普通)     |    0x00010000~0x7FFEFFFF                |  ~2GB
*   -----------------------------------------------------------------------------------
*     x86w/3GB      |    0x00010000~0xBFFEFFFF                |  ~3GB
*   -----------------------------------------------------------------------------------
*     x64           | 0x00000000'00010000~0x000007FF'FFFEFFFF |  ~8192GB
*   -----------------------------------------------------------------------------------
*     IA-64         | 0x00000000'00010000~0x000006FB'FFFEFFFF |  ~7152GB
*   -----------------------------------------------------------------------------------
*     在Windows中，所有.exe和动态链接库（dynamic-link library，通常简称为DLL）都载入到这一区域。每个进程都有可能将这些DLL载入到这一分区内的不同地址（虽然这种可能性很小）。系统同时
*   会把该进程可以访问的所有内存映射文件映射到这一分区。
* 6）内核模式分区
*     进程可用地址空间的数量居然还不到进程整个地址空间的一半。难道内核模式分区真的需要整个地址空间的上半部分吗？实际上，回答是肯定的。系统需要用这一空间来存放内核代码、设备驱动程序
*   代码、设备输入/输出高速缓存、非分页缓冲池分配表、进程页面表，等等。事实上，Microsoft已经将内核压缩到这2GB的空间中。在64位Windows中，内核终于得到它真正需要的空间。
*     这一分区是操作系统代码的驻地。与线程调度、内存管理、文件系统支持、网络支持以及设备驱动程序相关的代码都载入到该分区。驻留在这一分区内的任何东西为所有进程公有。虽然这一分区就在
*   每个进程中用户模式分区的上方，但该分区中所有代码和数据都被完全保护起来。如果一个应用程序试图读取或写入位于这一分区中的内存地址，会引发访问违规。
* 7）当系统创建一个进程并赋予它地址空间时，可用地址空间中的大部分都是闲置的(free)或尚未分配的(unallocated)。为了使用这部分地址空间，我们必须调用VirtualAlloc来分配其中的区域(region)。
*   分配区域的操作被称为预定（reserving）。
* 8）当应用程序预定地址空间区域时，系统会确保区域的起始地址正好是分配粒度（allocation granularity）的整数倍。分配粒度会根据不同的CPU平台而有所不同。但是，目前，所有的CPU平台都是用相同
*   的分配粒度，大小为64KB。
* 9）当应用程序预定地址空间中的一块区域时，系统会确保区域的大小正好事系统页面大小的整数倍。页面是一个内存单元，系统通过它来管理内存。与分配粒度相似，页面大小会根据不同的CPU而有所不同。
*   x86和x64系统使用的页面大小为4KB，而IA-64系统使用的页面大小为8KB。
* 10）有时系统会以应用程序的名义来预定地址空间区域。例如进程环境快（process environment block，后面简称PEB）和线程环境快（thread environment block，后面简称为TEB）。虽然系统规定应用程序
*   在预定地址空间区域时必须是分配粒度的整数倍，但系统自己确不存在同样的限制。
* 11）当程序不在需要访问所预定的地址空间区域时，应该释放该区域。这个过程被称为释放地址空间区域，通过调用VirtualFree函数来完成。
* 12）为了使用所预定的地址空间区域，我们还必须分配物理存储器，并将存储器映射到所预定的区域。这个过程被称为调拨（committing）物理存储器。物理存储器始终都以页面为单位来调拨。我们通过
*   调用VirtualAlloc函数来将物理存储器调拨给所预定的区域。当程序不在需要访问所预定区域中已调拨的物理存储器时，应该释放物理存储器。这个过程被称为撤销调拨（decommitting）物理存储器，通过
*   调用VirtualFree函数来完成。
* 13）物理存储器和页交换文件（https://www.jianshu.com/p/ca827ffa5ead）
*   当今的操作系统能让磁盘空间看起来像内存一样。磁盘上的文件一般被称为页交换文件（paging file），其中包含虚拟内存，可供任何进程使用。
* 14）当用户要求执行一个应用程序时，系统会打开该应用程序对应的.exe文件并计算出应用程序的代码和数据的大小。然后系统会预定一块地址空间，并注明与该区域相关联的物理存储器就是.exe文件本身。
*     是的，系统并没有从页交换文件中分配空间，而是将.exe文件的实际内容（或文件映像，即file image）用作程序预定的地址空间区域。这样一来，不但载入程序非常快，而且页交换文件也可以保持一个
*   合理的大小。
* 15）当把一个程序位于硬盘上的文件映像（即一个.exe或DLL文件）用作地址空间区域对应的物理存储器时，我们称这个文件映像为内存映射文件（memory mapped file）。当载入一个.exe或DLL时，系统会自动
*   预定地址空间区域并把文件映像映射到该区域。但是，系统也提供了一组函数，可以让开发人员把数据文件映射到地址空间。
* 16）Windows可以使用多个页交换文件。如果多个页交换文件位于不同的物理磁盘上，那么系统就可以运行得更快，这是因为系统能同时写入多个硬盘。
* 17）页面保护属性
*   我们可以给每个已分配的物理存储器页指定不同的页面保护属性。
*   ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
*           保护属性        |                                                           描 述
*   ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
*     PAGE_NOACCESS         |   试图读取页面、写入页面或执行页面中的代码将引发访问违规
*   ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
*     PAGE_READONLY         |   试图写入页面或执行页面中的代码将引发访问违规
*   ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
*     PAGE_READWRITE        |   试图执行页面中的代码将引发访问违规
*   ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
*     PAGE_EXECUTE          |   试图读取页面或写入页面将引发访问违规
*   ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
*     PAGE_EXECUTE_READ     |   试图写入页面将引发访问违规
*   ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
*     PAGE_EXECUTE_READWRITE|   对页面执行任何操作都不会引发访问违规
*   ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
*     PAGE_WRITECOPY        |   试图执行页面中的代码将引发访问违规。试图写入页面将使系统为进程单独创建一份该页面的私有副本（以页交换文件为后备存储器）
*   ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
*     PAGE_EXECUTE_WRITECOPY|   对页面执行任何操作都不会引发访问违规。试图写入页面将使系统为进程单独创建一份该页面的私有副本（以页交换文件为后备存储器）
*   ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
*     PAGE_NOCACHE          |   用来禁止对已调拨的页面进行缓存。该标志存在的主要目的是为了让需要操控内存缓冲区的驱动程序开发人员使用，不建议其他用途
*   ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
*     PAGE_WRITECOMBINE     |   也是给驱动程序开发人员用的。它允许把对单个设备的多次写操作组合在一起，以提高性能。
*   ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
*     PAGE_GUARD            |   使应用程序能够在页面中的任何一个字节被写入时得到通知。Windows在创建线程栈时会用到它。
*   ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
*     一些恶意软件将代码写入到用于数据的内存区域（比如线程栈上），通过这种方式让应用程序执行恶意代码。Windows的数据执行保护（Data Execution Protection，后面简称为DEP）特性提供了
*   对此类恶意攻击的防护。如果启用了DEP，那么只有对那些真正需要执行代码的内存区域，操作系统才会使用PAGE_EXECUTE_*保护属性。其他保护属性（最常见的就是PAGE_READWRITE）用于只应该
*   存放数据的内存区域（比如线程栈和应用程序的堆）。
*     系统还对Windows支持的结构化异常处理机制做了更进一步的保护。如果应用程序在链接时使用了/SAFESEH开关，那么异常处理器会被注册到映像文件中一个特殊的表中。这样，当将要执行一个
*   异常处理器时，操作系统会先检查该处理器有没有在表中注册过，然后决定是否允许它执行。
* 18）写时复制
*     Windows支持一种机制，允许两个或两个以上的进程共享同一块存储器。因此，如果有10个记事本程序正在运行，所有的进程会共享应用程序的代码页和数据页。让所有的应用程序实例共享相同
*   的存储页极大地提升了系统的性能，但另一方面，这也要求所有的应用程序实例只能读取其中的数据或是执行其中的代码。如果某个应用程序实例修改并写入一个存储页，那么这等于是修改了其他
*   实例正在使用的存储页，最终将导致混乱。
*     为了避免此类混乱的发生，操作系统会给共享的存储页指定写时复制属性。当系统把一个.exe或.dll映射到一个地址空间的时候，系统会计算有多少页面是可写的。然后系统会从页交换文件中
    分配存储空间来容纳这些可写页面。除非应用程序真的写入可写页面，否则不会用到页交换文件中的存储器。
        Hiberfil.sys：是Windows休眠时用于向磁盘写入内存内容的；
        Pagefile.sys：是用于在操作系统内存不足时临时交换数据的；
        Swapfile.sys：主要用于交换Universal Apps的相关数据
*     当线程试图写入一个共享页面时，系统会介入并执行下面的操作。
*       （1）系统在内存中找到一个闲置页面。注意，该闲置页面的后备页面来自页交换文件，它是系统最初将模块映射到进程的地址空间时分配的。由于系统在第一次进行映射的时候分配了所有
*           可能需要的页交换文件空间，这一步不可能失败。
*       （2）系统把线程想要修改的页面内容复制到在第1步中找到的闲置页面。系统会给该闲置页面指定PAGE_READWRITE或PAGE_EXECUTE_READWRITE保护属性，系统不会对原始页面的保护属性和
*           数据做任何修改。
*       （3）然后，系统更新进程的页面表，这样一来，原来的虚拟地址现在就对应到内存中一个新的页面了。系统在执行这些步骤之后，进程就可以访问它自己的副本了。
*     此外，在预定地址空间或调拨物理存储器时，不能使用PAGE_WRITECOPY或PAGE_EXECUTE_WRITECOPY保护属性。这两个属性是操作系统在映射.exe或DLL映像文件时用的。
* 18）内存的区域类型
*   ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
*      类 型   |                                                  描 述
*   ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
*     闲置     | 区域的虚拟地址没有任何后备存储器。该地址空间尚未预定，应用程序既可以从基地址开始预定区域，也可以从限制区域内的任何地方开始预定区域
*   ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
*     私有     | 区域的虚拟地址以系统的页交换文件为后备存储器
*   ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
*     影像     | 区域的虚拟地址一开始以映像文件（比如.exe或DLL文件）为后备存储器，但此后不一定以影像文件为后备存储器。例如，如果程序写入影像文件中的一个
*              | 全局变量，那么写时复制机制会改用页交换文件来作为后备存储器
*   ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
*     已映射   | 区域的虚拟地址一开始以内存映射文件为后备存储器，但此后不一定以内存映射文件为后备存储器。例如，内存映射文件可能会使用写时复制保护属性。
*              | 任何写操作会使对应的页面改用页交换文件来作为后备存储器
*   ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
* 19）读者可能会注意到磁盘上的文件大小和映射到内存所需要的字节数之间的差异。为了节省磁盘空间，链接器会尽可能地对所生成的PE文件进行压缩。但是，当Windows将PE文件映射到进程
*   的虚拟地址空间时，每一段（section）必须另起一页，而且起始地址必须是系统页面大小的整数倍。这意味着PE文件所需虚拟地址空间的大小一版来说要大于文件本身的大小。
* 20）块：一个块（block）是一些连续的页面，这些页面具有相同的保护属性，并且以相同类型的物理存储器为后备存储器。
* 21）数据对齐
*     相较于操作系统的内存体系结构，数据对齐更多的是CPU体系结构的一部分。只有当访问已对齐的数据时，CPU的执行效率才最高。把数据的地址模除数据的大小，如果结果为0，那么数据就是对齐的。
*     例如，一个WORD值的起始地址应该能被2整除，一个DWORD值的起始地址应该能被4整除，以此类推。如果CPU要访问的数据没有对齐，那么会有两种可能。
*       a.CPU会引发一个异常；
*       b.CPU会通过多次访问已对齐的内存，来取得整个错位数据。
*     x86CPU的EFLAGS寄存器内有一个特殊的标志位，它被称为AC(alignment check，对齐检查)标志。在默认的情况下，这个标志位的第一次给CPU通电时被清零。如果该标志为零，那么CPU会自动执行
*   必要的操作来访问错位数据。但是，如果该标志被设为1，那么一旦程序试图访问错位数据，CPU就会触发INT17H中断。由于x86版本的Windows从来不会改变这个标志，因此当应用程序在x86处理器上
*   运行时，绝对不会发生数据错误的异常。当应用程序在AMDx86-64处理器上运行时，会得到同样的结果。但是在IA-64CPU下，则不太相同。
* 22）GlobalMemoryStatus函数返回的物理内存数量比实际物理内存少，这是因为系统在启动过程中会为非页面缓冲池（一个包含各种系统虚拟地址范围的内存池）保留一部分内存。甚至连内核都不能
    使用这些内存。
* 23）我们把一个进程的地址空间中被保存在内存里的那些页面称为它的工作集（working set）。
* 24）扩展版的VMQuery(HANDLE hProcess,  LPCVOID pvAddress, PVMQUERY pVMQ)：可以获得更完整的内存信息（某个已预订区域的大小，或者某个区域中央的数量，某个区域是否包含有线程栈）。
* 25）Windows Vista提供的一个名为地址空间布局随机化（Address Space Layout Randomization, 后面称为ASLR）的新特性。该特性允许Windows在第一次载入一个DLL时，为它选择一个不同的基地址。
*   地址空间布局随机化的目的是为了让黑客们更难以发现常用系统DLL的地址，以此来避免其中的代码被恶意软件利用。
* 26）Microsoft Windows提供了以下三种机制来对内存进行操控。
*       ・虚拟内存：最适合用来管理大型对象数组或大型结构数组。
*       ・内存映射文件：最适合用来管理大型数据流（通常是文件），以及在同一机器上运行的多个进程之间共享数据。
*       ・堆：最适合用来管理大量的小型对象。
*     Windows提供了一些用来操控虚拟内存的函数，我们可以通过这些函数直接预定地址空间区域，给区域调拨（来自页交换文件的）物理存储器，以及根据自己的需求来设置页面的保护属性。
* 27）实现垃圾收集函数的一种极佳的方式是让它作为一个低优先级的线程来运行。在这种方式下，我们没有占用主应用程序运行的时间。当主应用程序闲置时，或主应用程序的线程在执行文件操作时，
*   系统就可以给垃圾收集函数调度时间，并让它执行。
*/

#include <Windows.h>
#include <psapi.h>

namespace HY_MEMORYOBJECT
{
	class CHYMemoryObject
	{
    public:
        CHYMemoryObject();
        virtual ~CHYMemoryObject();

        // 取得与主机相关的信息：页面大小和分配粒度等
        static VOID GetSystemInfo(LPSYSTEM_INFO psi);

        // 如果想要知道进程是否在WOW64上运行
        static BOOL IsWow64Process(HANDLE hProcess, PBOOL pbWow64Process);

        // 当32位应用程序在WOW64上运行时，需要调用
        static void GetNativeSystemInfo(LPSYSTEM_INFO lpSystemInfo);

        static BOOL IsOS(DWORD dwOS);

        // 获取虚拟内存的状态
        static VOID GlobalMemoryStatus(LPMEMORYSTATUS lpBuffer);
        static BOOL GlobalMemoryStatusEx(LPMEMORYSTATUSEX pmst);

        /* NUMA机器中的内存管理 */ 
        // 获取某个特定NUMA节点的内存数量
        static BOOL GetNumaAvailableMemoryNode( UCHAR uNode, PULONGLONG pulAvailableBytes);
        // 获取某个CPU驻留的NUMA节点
        static BOOL GetNumaProcessorNode( UCHAR Processor, PUCHAR NodeNumber);
        // 获取系统中节点的总数
        static BOOL GetNumaHighestNodeNumber(PULONG pulHighestNodeNumber);
        // 获取驻留在某个节点中的CPU列表
        static BOOL GetNumaNodeProcessorMask(UCHAR uNode, PULONGLONG pulProcessorMask);

        // 取得进程当前工作集的大小和最大工作集的大小
        static BOOL GetProcessMemoryInfo(HANDLE hProcess, PPROCESS_MEMORY_COUNTERS ppmc, DWORD cbSize);

        // 查询与地址空间中的内存地址有关的特定信息
        static DWORD VirtualQuery(LPCVOID pvAddress, PMEMORY_BASIC_INFORMATION pmbi, DWORD dwLength);
        static DWORD VirtualQueryEx(HANDLE hProcess, LPCVOID pvAddress, PMEMORY_BASIC_INFORMATION pmbi, DWORD dwLength);
	};
}

