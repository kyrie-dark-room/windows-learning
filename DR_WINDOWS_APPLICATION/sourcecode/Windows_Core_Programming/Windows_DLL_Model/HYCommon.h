#pragma once
/*
* 知识点：
* 1）自从Microsoft Windows第一个版本的诞生之日起，动态链接库（dynamic-link library, DLL）一直以来都是该操作系统的基石。Windows应用程序编程接口（application programming interface， API）
*	提供的多有函数都包含在DLL中。其中三个最重要的DLL分别是：Kernel32.dll，包含的函数用来管理内存、进程以及线程；User32.dll，包含的函数用来执行与用户界面相关的任何，如创建窗口和发送消息；
*	GDI32.dll，包含的函数用来绘制图像和显式文字。
* 2）下面是为什么要使用DLL的一些理由。
*		・ 它们扩展了应用程序的特性
*		・ 它们简化了项目管理
*		・ 它们有助于节省内存
*		・ 它们促进了资源的共享
*		・ 它们促进了本地化
*		・ 它们有助于解决平台间的差异
*		・ 它们可以用于特殊目的：Windows提供的某些特性只有DLL才能使用。
* 3）在所有的源文件编译完成之后，链接器会像链接应用程序的可执行文件那样，对它们进行链接，但在创建DLL的时候，我们必须给链接器指定/DLL开关。这个开关会使链接器在生成的DLL文件映像中保存一些
*	与可执行文件略微不同的信息，这样操作系统的加载程序就能够将该文件映像识别为DLL，而不会将它识别为应用程序。
* 4）在应用程序（或其他DLL）能够调用一个DLL中的函数之前，必须将该DLL的文件映像映射到调用进程的地址空间中。我们可以通过两种方法来达到这一目的：
*		・ 隐式载入时链接（implicit load-time linking）
*		・ 显式运行时链接（explicit run-time linking）
* 5）纵观全局
	 构建DLL需要以下步骤：
	 ・必须先创建一个头文件，在其中包含我们想要在DLL中导出的函数原型、结构以及符号。为了构建该DLL，DLL的所有源文件需要包含这个头文件。正如我们稍后可以看到，在构建可执行文件的时候需要
	   用到同一个头文件。
	 ・创建C/C++源文件来实现想要在DLL模块中导出的函数和变量。由于在构建可执行模块的时候不需要这些源文件，因此创建该DLL的公司可以将这些源代码作为公司的机密。
	 ・在构建该DLL模块的时候，编译器会对每个源文件进行处理并产生一个.obj模块（每个源文件对应一个.obj模块）。
	 ・当所有.obj模块都创建完毕后，链接器会将所有.obj模块的内容合并起来，产生一个单独的DLL映像文件。这个映像文件（或模块）包含DLL中所有的二进制代码以及全局/静态变量。为了执行可执行
	   模块，这个文件是必须的。
	 ・如果链接器检测到DLL的源文件输出了至少一个函数或变量，那么链接器还会生成一个.lib文件。这个.lib文件非常小，这是因为它并不包含任何函数或变量。它只是列出了所有被导出的函数和变量
	   的符号名。为了构建可执行模块，这个文件是必须的。
	 一旦构建了DLL模块，我们就可以通过下列步骤来构建可执行模块。
	 ・在所有引用了导出的函数、变量、数据结构或符号的源文件中，必须包含由DLL的开发人员所创建的头文件。
	 ・创建C/C++源文件来实现想要包含在可执行模块中的函数和变量。当然，代码可以引用在DLL的头文件中定义的函数和变量。
	 ・在构建可执行模块的时候，编译器会对每个源文件进行处理并产生一个.obj模块（每个源文件对应一个.obj模块）。
	 ・当所有.obj模块都创建完毕后，链接器会将所有.obj模块的内容合并起来，产生一个单独的可执行映像文件。这个映像文件（或模块）包含了可执行文件中所有的二进制代码以及全局/静态变量。
	   可执行模块还包含一个导入段（import section），其中列出了所有它需要的DLL模块的名称。此外，对列出的每个DLL，该段还记录了可执行文件的二进制代码从中引用的函数和变量的符号名。
	   操作系统的加载程序会解析这个导入段，我们一会就会看到。
	   一旦DLL和可执行模块都已构建完毕，进程就可以执行了。当我们试图运行可执行模块的时候，操作系统的加载程序会执行下面的步骤。
	 ・加载程序先为新的进程创建一个虚拟地址空间，并将可执行模块映射到新进程的地址空间中。加载程序接着解析可执行模块的导入段。对导入段中列出的每个DLL，加载程序会在用户的系统中对
	   该DLL模块进行定位，并将该DLL映射到进程的地址空间中，注意，由于DLL模块可以从其他DLL模块中导入函数和变量，因此DLL模块可能有自己的导入段并需要将它所需的DLL模块映射到进程的
	   地址空间中。我们可以看到，初始化一个进程可能会耗费很长的时间。
	 一旦加载程序将可执行模块和所有DLL模块映射到进程的地址空间之后，进程的主线程可以开始执行，这样应用程序就能够运行了。
* 5）一个DLL可以导出变量、函数或C++类来供其他模块使用。在实际开发中，我们应该避免从DLL中导出变量，因为这样等于是去掉了代码中的一个抽象层，从而使得DLL的代码更加难以维护。此外，
*	只有当导出C++类的模板使用的编译器与导入C++类的模板使用的编译器由同一家厂商提供时，我们才可以导出C++类。因此，除非知道可执行模块的开发人员与DLL模块的开发人员使用的是相同的
	工具包，否则我们应该避免从DLL中导出C++类。
* 6）extern "C" 用来告诉编译器不要对变量名或函数名进行改编，这样用C、C++或任何编程语言编写的可执行模块都可以访问该变量或函数。
* 7）关于__declspec(dllexport)修饰符了。当Microsoft的C/C++编译器看到用这个修饰符修饰的变量、函数原型或C++类的时候，会在生成的.obj文件中嵌入一些额外的信息。当链接器在链接DLL所有
*	的.obj文件时，会解析这些信息。
*	 在链接DLL的时候，链接器会检测到这些与导出的变量、函数或类有关的嵌入信息，并生成一个.lib文件。这个.lib文件列出了该DLL导出的符号。在链接任何可执行模块的时候，只要可执行模块
*	引用了该DLL导出的符号，那么这个.lib文件当然是必需的。除了创建这个.lib文件之外，链接器还会在生成的DLL文件中嵌入一个导出符号表。这个（按字母排序排列的）导出段（export section）
*   列出了导出的变量、函数和类的符号名。链接器还会保存相对虚拟地址（relative virtual address，RVA），表示每个符号可以在DLL模块中的何处找到。
* 8）我们可以通过Microsoft Visual Studio提供的DumpBin.exe工具（加上-exports开关）来查看一个DLL的导出段。
* 9）即使完全用C来编程，但使用了不同厂商提供的工具包，还是会遇到另外一个问题。这个问题就是，即使根本没有用到C++，Microsoft的C编译器也会对C函数的名称进行改编。只有当我们的函数
*	使用了__stdcall(WINAPI)调用约定的时候，才会发生这种情况。但不巧的是，这个调用约定是最常见的类型。当使用__stdcall来导出C函数的时候，Microsoft的编译器会对函数名进行改编，具体
*	的方法是给函数名添加下划线前缀和一个特殊的后缀，该后缀由一个@符号后跟作为参数传递给函数的字节数组成。例如，下面的函数在DLL的导出段中被导出为_MyFunc@8。
*		__declspec(dllexport) LONG __stdcall MyFunc(int a, int b);
*	 为了用Microsoft的工具包来构建一个能与其他编译器厂商的工具包链接的DLL，我们必须告诉Microsoft编译器不要对导出的函数名进行改编。我们可以通过两种方法来达到这一目的。
*		a.第一种方法是为我们的项目创建一个.def文件，并在.def文件中包含以下类似下面的EXPORTS段：
*			EXPORTS
*				MyFunc
*		  当Microsoft链接器解析这个.def文件的时候，会发现_MyFunc@8和MyFunc都被导出。由于这两个函数名是匹配的（不考虑改编），因此链接器会用.def文件中定义的名称，而根本不会用_MyFunc@8
*		 来导出函数。
*		  另外，在用Microsoft的工具包来构建可执行文件并链接到一个DLL的时候，如果该DLL包含的符号名未经改编。Microsoft的链接器在处理这种情况时，能够做出正确的选择，并将可执行文件链接到
*		 名为MyFunc的函数。
*		b.第二种方法：我们可以在DLL的源文件中添加一行类似下面的代码：
*			#pragma comment(linker, "/export:MyFunc=_MyFunc@8")
*		  该行代码会使得编译器产生一个链接器指示符，该指示符告诉链接器要导出一个名为MyFunc的函数，该函数的入口点与_MyFunc@8相同。
* 10）链接器只想知道被引用的符号确实存在，以及该符号来自哪个DLL模块。如果链接器能够解决(resolve)对所有外部符号的引用，那么它将生成可执行模块。
* 11）在导入符号的时候，不必使用__declspec(dllimport)关键字，而可以直接使用标准C语言的extern关键字。但是，如果编译器能够提前知道我们引用的符号是从一个DLL的.lib文件中导入的，那么它将
*	 能够产生略微高效的代码。
* 12）我们可以使用Visual Studio的DumpBin.exe工具（加上-imports开关）来查看一个模块的导入段(import section)。导入段列出了模块所需的DLL模块，以及它从每个DLL模块中引用的符号。
* 13）由于导入段只包含DLL的名称，不包含DLL的路径，因此加载程序必须在用户的磁盘上搜索DLL。下面是加载程序的搜索顺序。
*		a.包含可执行文件的目录。
*		b.Windows的系统目录，该目录可以通过GetSystemDirectory得到。
*		c.16位的系统目录，即Windows目录中的System子目录。
*		d.Windows目录，该目录可以通过GetWindowsDirectory得到。
*		e.进程的当前目录。
*		f.PATH环境变量中所列出的目录。
* 14）当加载程序将所有DLL模块都载入并映射到进程的地址空间中后，它开始修复所有对导入符号的引用。为了完成这一工作，它会再次查看每个模块的导入段。对导入段中列出的每个符号，加载程序
*	 会检查对应DLL的导出段，看该符号是否存在。如果该符号不存在（这种情况实属罕见），那么会弹出错误提示框。如果该符号存在，那么加载程序会取得该符号的RVA并给它加上DLL模块被载入到
*	 的虚拟地址（从而得到符号在进程的地址空间中的位置）。接着加载程序会将这个虚拟地址保存到可执行模块的导入段中。现在，当代码引用到一个导入符号的时候，会查看调用模块的导入段并
*	 得到被导入符号的地址，这样就能够成功地访问被导入的变量、函数或C++类成员函数了。
* 15）加载程序要载入所有这些DLL模块，并用所有导出符号的正确地址来修复每个模块的导入段，这自然需要相当多的时间。由于这项工作是在进程初始化的时候完成的，因此它不会对应用程序的性能
*	 产生影响。但是，对许多应用程序来说，初始化过程太慢也是不可接受的。为了减少应用程序的载入时间，我们应该对自己的可执行模块和DLL模块进行基地址重定位和绑定。这两项技术极为重要，
*	 但不幸的是，很少有开发人员知道该如何应用它们。如果每家公司都应用这两项技术， 那么整个系统会运行得更好。
* 16）函数转发器(function forwarder)是DLL输出段中的一个条目，用来将一个函数调用转发到另一个DLL中的另一个函数。
*		示例：
*		C:\Windows\System32>DumpBin -Exports Kernel32.dll
*		75	49	CloseThreadpoolIo	(forwarded to NTDLL.TpReleaseIoCompletion)
*	  我们也可以在自己的DLL模块中使用函数转发器。最简单的方法是使用pragma指示符，如下面所示：
*		// Function forwarders to functions in DllWork
*		#pragma comment(linker, "/export:SomeFunc=DllWork.SomeOtherFunc")
* 17）已知的DLL
*	  系统对操作系统提供的某些DLL进行了特殊处理，这些DLL被称为已知的DLL(known DLL)。除了操作系统在载入它们的时候总是在同一个目录中查找之外，他们与其他的DLL并没有什么不同。
*	  在注册表中有这么一个注册表项：HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs。我们可以看到，这个注册表项包含了一组值名。
*	  当LoadLibrary或LoadLibraryEx被调用的时候，函数首先会检查我们传入的DLL的名字是否包含了.dll扩展名。如果没有包含，那么函数会用正常的搜索规则来搜索这个DLL。如果我们指定了.dll扩展名，
*	 那么这两个函数会先将扩展名去掉，然后再在KnownDLLs注册表项中搜索，看其中是否有与之相符的值名。如果没有值名与之相符，那么函数会使用正常的搜索规则。但是，如果找到了与之相符的值名，
*	 那么系统会查看与值名相对应的数据，并试图用该数据来载入DLL。系统还会从这个注册表项的DllDirectory值所表示的目录中开始搜索DLL。在Windows Vista中，DLLDirectory的默认值为
	 %SystemRoot%\System32。
* 18）Microsoft现在强烈建议开发人员将应用程序的文件放到自己的目录中，并且绝对不要碰Windows系统目录中的任何东西。这样既可以防止我们的应用程序妨碍其他应用程序，也可以避免其他应用
*    程序妨碍我们的应用程序。
*     为了帮助开发人员，Microsoft自Windows 2000开始新增了一项DLL重定向特性。这项特性强制操作系统的加载程序首先从应用程序的目录中载入模块。只有当加载程序无法找到要找的文件时，才会
*    在其他的目录中搜索。
*	  为了强制加载程序总是先检查应用程序的目录，我们所要做的就是将一个文件放到应用程序的目录中。这个文件的内容无关紧要，但它的文件名必须是AppName.local。
*	  LoadLibrary(Ex)在内部做了修改，来检查这个文件存在与否。如果应用程序的目录中存在这个文件，那么系统会载入这个目录中的模块。如果应用程序的目录中不存在这个文件，那么LoadLibrary(Ex)
*	 的工作方式与以往相同。注意，除了创建一个.local文件，我们还可以创建一个名为.local的文件夹。在这种情况下，我们可以将自己的DLL保存在这个文件夹中，让Windows能够轻易地找到它们。
*	  注意，为了安全性的缘故，Windows Vista中这项特性在默认情况下是关闭的--因为它可能会使系统从应用程序的文件夹中载入伪造的系统DLL，而不是从Windows的系统文件夹中载入真正的系统DLL>
*    为了打开这项特性，我们必须在HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options注册表项中增加一个条目DWORD DevOverrideEnable，并将它
*	 的值设为1。
* 19）模块的基地址重定位
	  每个可执行文件和DLL模块都有一个首选基地址(preferred base address)，它表示在将模块映射到进程的地址空间中时的最佳内存地址。当我们在构建一个可执行模块的时候，链接器会将模块的
*	 首选基地址设为0x00400000。对DLL模块来说，链接器会将首选基地址设为0x10000000。
*	  当链接器在构建我们的模块时，会将重定位段(relocation section)嵌入到生成的文件中。这个段包含一个字节偏移量的列表，每个字节偏移量表示一条机器指令所使用的一个内存地址。如果加载
*	 程序能够将模块载入到它的首选基地址，那么系统就不会访问模块的重定位段。另一方面，如果加载程序无法将模块载入到它的首选基地址，那么系统会打开模块的重定位段并遍历其中所有的条目。
*    对每一个条目，加载程序会先找到包含机器指令的那个存储页面，然后将模块的首选基地址与模块的实际映射地址之间的差值，加到机器指令当前正在使用的内存地址上。
*	  当一个模块无法被载入到它的首选基地址时，存在以下两个主要的缺点：
*		・加载程序必须遍历重定位段并修改模块中大量的代码。这个过程不仅是一大性能杀手，而且也确实会损害应用程序的初始化时间。
*		・当加载程序写入到模块的代码页面中时，系统的写时复制机制会强制这些页面以系统的页交换文件为后备存储器。
*     顺便提一下，我们也可以创建一个不包含重定位段的可执行文件或DLL模块。在构建模块的时候使用/FIXED开关就能够达到这个目的。这个开关可以让模块的大小变小，但它同时意味着模块无法被重定位。
*	  对于一个资源DLL来说，这是一个问题。一个资源DLL不包含任何代码，因此在链接的时候使用/FIXED开关是非常合理的。但是，如果一个资源DLL无法被载入到它的首选地址，那么该模块就根本不会被
*	 载入。这简直是可笑！为了解决这个问题，链接器允许我们在创建模块的时候在头文件中嵌入一些信息，来表示该模块之所以不包含重定位信息，是因为没有这个必要。Windows的加载程序会使用头文件
*    中的这些信息，并能够在不牺牲性能和页交换文件空间的前提下，将资源DLL载入。
*	  为了创建一个不包含任何重定位信息的映像，应该用/SUBSYSTEM:WINDOWS，5.0开关或/SUBSYSTEM:CONSOLE，5.0开关，而不要指定/FIXED开关。如果链接器检测到模块中没有东西需要进行重定位修正，
*	 那么它会将模块中的重定位段省略掉，并在文件头中关闭一个特殊的IMAGE_FILE_RELOCS_STRIPPED标志。当Windows载入该模块的时候，会发现该模块可以重定位（因为IMAGE_FILE_RELOCS_STRIPPED被关闭），
*    但它实际上并不包含重定位信息（因为重定位段不存在）。注意，这是Windows 2000加载程序的一项新特性，因此/SUBSYSTEM开关的最后一部分必须是5.0也就不足为奇了。
*	  * 我们现在已经理解了首选基地址的重要性。因此，如果要将多个模块载入到同一个地址空间中，那么我们必须给每个模块指定不同的首选基地址。
*		・Visual Studio的Project Properties对话框可以方便的进行设置，选中Configuration Properities\Linker\Advanced属性页，然后在Base Address一栏中输入一个数值即可。
*		・Visual Studio提供了一个名为Rebase.exe的工具，能让我们给所有模块设置不错的首选基地址（Rebase是一个很棒的工具，我极力推荐使用它）。
*		  如果在执行Rebase工具的时候传给它一组映像文件名，那么它会执行下列操作。
*			a.它会模拟创建一个进程地址空间。
*			b.它会打开应该被载入到这个地址空间中的所有模块，并得到每个模块的大小以及它们的首选基地址。
*			c.它会在模拟的地址空间中对模块重定位的过程进行模拟，使各模块之间没有重叠。
*			d.对每个重定位过的模块，它会解析该模块的重定位段，并修改模块在磁盘文件中的代码。
*			e.为了反应新的首选基地址，它会更新每个重定位过的模块的文件头。
*		・通过调用ImageHlp API提供的ReBaseImage函数，我们也可以实现自己的重定位工具。
* 20）模块的绑定
	  我们甚至还能再进一步提高性能。假设我们已经对应用程序的所有模块进行了基地址重定位。加载程序将符号的虚拟地址写入到可执行文件模块的导入段中。这使得在程序引用导入的符号时，实际上
*	 引用的是正确的内存地址。
*	  让我们想一想这个过程，如果加载程序将导入符号的虚拟地址写入到.exe模块的导入段，那么会写入段的后备存储页面。由于这些页面具有写时复制属性，因此它们以页交换文件为后备存储器。所以
	 我们会遇到一个与基地址重定位相似的问题：系统必须将映像文件的一部分从内存换出到页交换文件，并从页交换文件换入到内存，而不能直接抛弃内存中的页面并在需要的时候再从文件的磁盘映像中
	 重新读取。另外，加载程序必须解析（所有模块的）所有导入符号的地址，这可能会耗费很长的时间。
	  我们可以采用模块绑定技术，这样应用程序就可以更快地初始化并使用更少地存储器。对一个模块进行绑定，使用该模块导入地所有符号地虚拟地址，来对该模块地导入段进行预处理。
	  Visual Studio提供了一个名为Bind.exe的工具来帮助我们完成这一工作。
	  但是，与Rebase相似，我们也可以通过调用ImageHlp API提供地BindImageEx函数来实现相同的特性。
	  如果在执行Bind工具的时候传给它一个映像文件名，它会执行下列操作
		・它会打开指定的映像文件的导入段
		・对导入段中列出的每个DLL，它会查看该DLL文件的文件头，来确定该DLL的首选基地址。
		・它会在DLL的导出段中查看每个符号。
		・它会取得符号的RVA，并将它与模块的首选基地址相加。它会将计算得到的地址，也就是导入符号预期的虚拟地址，写入到映像文件的导入段中。
		・它会在映像文件的导入段中添加一些额外的信息。这些信息包括映像文件被绑定到的各DLL模块的名称，以及各模块的时间戳。
	  注意：我们应该在应用程序的安装过程中来进行绑定。
* 20）有时将数据与一个对象的实例关联起来是帮助的。我们可以使用线程局部存储区（Thread Local Storage，后面简称为TLS）来将数据与一个正在执行的指定线程关联起来。
* 21）C/C++运行库使用了TLS。由于C/C++运行库是在多线程应用程序出现的许多年之前设计的，因此运行库中的大多数函数是为单线程应用程序设计的。
* 22）在我自己的软件项目中，我尽量避免使用全局变量。如果读者的应用程序使用了全局变量和静态变量，那么我强烈建议你对每个变量进行分析，并研究将它们改成栈上的变量的可能性。如果想
*	 在应用程序中添加更多的线程，那么这项工作能够帮你节省大量的时间，不仅如此，甚至单线程应用程序也能从中受益。
* 23）应用程序通过调用一组4个函数来使用动态TLS，这些函数实际上最经常为DLL所使用。系统中的每个进程都有一组正在使用标志（in-use flag）。每个标志可以被设为FREE或UNUSE，表示该TLS
*	 元素是否正在使用。Microsoft保证至少有TLS_MINIMUM_AVAILABLE个位标志可供使用。顺便说一下，TLS_MINIMUM_AVAILABLE在WinNT.h中被定义为64，系统会在需要的时候分配更多的TLS元素，
*	 最多可达1000多个！这对任何应用程序来说都应该够了。
* 24）通常，如果DLL要使用TLS，那它会在DllMain函数处理DLL_PROCESS_ATTACH的时候调用TlsAlloc，在DllMain处理DLL_PROCESS_DETACH的时候调用TlsFree。而对TlsSetValue和TlsGetValue的调用
*	 则最有可能发生在DLL所提供的其他函数中。
* 25）TlsAlloc在返回之前，会遍历进程中的每个线程，并根据新分配的索引，在每个线程的数组中把对应的元素设为0。
* 26）与动态TLS相似，静态TLS也将数据与线程关联起来。但是，由于使用的时候不必在代码中调用任何函数，因此静态TLS更容易使用。假设想将应用程序创建的每个线程与该线程的启动时间关联起来。
*	 我们要做的就是像下面这样声明一个启动时间：
*			__declspec(thread) DWORD gt_dwStartTime = 0;
*	  __declspec(thread)前缀是Microsoft为Visual C++编译器增加的一个修饰符。它告诉编译器应该在可执行文件或DLL文件中，把对应的变量放到它自己的段中。
*	  当编译器对程序进行编译的时候，会将所有TLS变量放到它们自己的段中，这个段名为.tls。链接器会将所有对象模块中的.tls段合并成一个大的.tls段，并将它保存到生成的可执行文件或DLL文件中。
*	  为了让TLS能够正常工作，操作系统也必须参与进来。当系统将应用程序载入到内存的时候，会查看可执行文件的.tls段，并分配一块足够大的内存来保存所有的静态TLS变量。每当应用程序中的代码
*	 引用到这些变量之一时，相应的引用会被解析到刚分配的这块内存中的一个位置。因此，编译器必须生成额外的代码来引用静态TLS变量，这使得应用程序不仅变得更大，而且执行起来也更慢。
*	  如果进程创建了另一个线程，那么系统会获知这一情况并自动分配另一块内存来保存新线程的静态TLS变量。新线程只能访问自己的静态TLS变量，它无法访问属于任何其他线程的TLS变量。
*/
