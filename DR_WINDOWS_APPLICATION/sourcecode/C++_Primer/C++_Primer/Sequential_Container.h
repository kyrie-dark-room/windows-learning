#pragma once

/*
1. 顺序容器类型
------------------------------------------------------------------------------------------------------
										顺序容器类型
------------------------------------------------------------------------------------------------------
vector					可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢

deque					双端队列。支持快速随机访问。在头尾位置插入/删除速度很快

list					双向链表。只支持双向顺序访问。在list中任何位置进行插入/删除操作速度都很快

forward_list			单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快

array					固定大小数组。支持快速随机访问。不能添加或删除元素

string					与vector相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快
-----------------------------------------------------------------------------------------------------

2. 通常，使用vector是最好的选择，除非你有很好的理由选择其他容器。
3. 较旧的编译器可能需要在两个尖括号之间插入空格，例如，vector<vector<string> >。
4. 容器操作
-----------------------------------------------------------------------------------------------------
												容器操作
-----------------------------------------------------------------------------------------------------
类型别名
iterator				此容器类型的迭代器类型
const_iterator			可以读取元素，但不能修改元素的迭代器类型
size_type				无符号整形类型，足够保存此种容器类型最大可能容器的大小
difference_type			带符号整形类型，足够保存两个迭代器之间的距离
value_type				元素类型
reference				元素的左值类型：与value_type&含义相同
const_reference			元素的const左值类型（即，const_value_type&）

构造函数
C c;					默认构造函数。如果C是一个array，则c中元素按默认方式初始化；否则c为空。

C c1(c2);				c1初始化为c2的拷贝。c1和c2必须是相同类型（即，它们必须是相同的容器类型，且
C c1=c2					保存的是相同的元素类型；对于array类型，两者还必须具有相同的大小）

C c(b, e);				c初始化为迭代器b和e指定范围中的元素的拷贝。范围中元素的类型必须与C元素类型相容

C c(a,b,c...)			c初始化为初始化列表中元素的拷贝。列表中元素的类型必须与c的元素类型相容。对于
C c=(a,b,c...)			array类型，列表中元素数目必须等于或小于array的大小，任何遗漏的元素都进行值初始化

C seq(n)				只有顺序容器(不包括array)的构造函数才能接受大小参数。seq包含n个元素，这些元素
						进行了值初始化；此构造函数时explicit
C seq(n, t)				seq包含n个初始化为值t的元素

赋值与swap
c1=c2					将c1中的元素替换为c2中元素
c1={a, b, c...}			将c1中的元素替换为列表中元素(不适用于array)
a.swap(b)				交换a和b的元素，元素本身并未交换，只是交换了两个容器的内部数据结构，因此可以保证
swap(a, b)				在常数时间内完成。与a.swap(b)等价

seq.assign(b,e)			将seq中的元素替换为迭代器b和e所表示的范围中的元素。迭代器b和e不能指向seq中的元素
seq.assign(il)			将seq中的元素替换为初始值列表il中的元素
seq.assign(n,t)			将seq中的元素替换为n个值为t的元素

大小
c.size()				c中元素的数目(不支持forward_list)
c.max_size()			c可保持的最大元素数目
c.empty()				若c中存储了元素，返回false，否则返回true

添加/删除元素（不适用于array）
注：在不同容器中，这些操作的接口都不同
c.insert(args)			将args中元素拷贝进c
c.emplace(inits)		使用inits构造c中的一个元素
c.erase(args)			删除args指定的元素
c.clear()				删除c中的所有元素，返回void

关系运算符
==, !=					所有容器都支持相等(不等)运算符
<, <=, >, >=			关系运算符（无须关联容器不支持）

获取迭代器
c.begin(), c.end()		返回指向c的首元素和尾元素之后位置的迭代器
c.cbegin(), c.cend()	返回const_iterator

反向容器的额外成员（不支持forward_list）
reverse_iterator		按逆序寻址元素的迭代器
const_reverse_iterator	不能修改元素的逆序迭代器
c.rbegin(), c.rend()	返回指向c的尾元素和首元素之间位置的迭代器
c.crbegin(), c.crend()	返回const_reverse_iterator
-----------------------------------------------------------------------------------------------------

5. 当不需要写访问时，应使用cbegin和cend。
6. 为了创建一个容器为另一个容器的拷贝，两个容器的类型及其元素类型必须匹配。不过，当传递迭代器参数来拷贝
一个范围时，就不要求容器类型是相同的了。而且，新容器和原容器中的元素类型也可以不同，只要能将要拷贝的元素
转换为要初始化的容器的元素类型即可。
7. 与内置数组一样，标准库array的大小也是类型的一部分。当定义一个array时，除了指定元素类型，还要指定容器大小
8. 赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效。而swap操作将容器内容交换不会导致指向容器的
迭代器、引用和指针失效（容器类型为array和string的情况除外）。
9. 非成员版本的swap在泛型编程中是非常重要的。统一使用非成员版本的swap是一个好习惯。

10.向顺序容器添加元素的操作
-----------------------------------------------------------------------------------------------------
										向顺序容器添加元素的操作
-----------------------------------------------------------------------------------------------------
这些操作会改变容器的大小；array不支持这些操作。
forward_list 有自己专有版本的insert和emplace；
forward_list 不支持push_back和emplace_back。
vector和string不支持push_front和emplace_front

c.push_back(t)			在c的尾部创建一个值为t或由args创建的元素。返回void
c.emplace_back(args)

c.push_front(t)			在c的头部创建一个值为t或由args创建的元素。返回void
c.emplace_front(args)	

c.insert(p,t)			在迭代器p指向的元素之前创建一个值为t或由args创建的元素。返回指向新添加的元素
c.emplace(p, args)		的迭代器

c.insert(p,n,t)			在迭代器p指向的元素之前插入n个值为t的元素。返回指向新添加的第一个元素的迭代器；
						若n为0，则返回p
c.insert(p,b,e)			将迭代器b和e指定范围内的元素插入到迭代器p指向的元素之前。b和e不能指向c中的元素。
						返回指向新添加的第一个元素的迭代器；若范围为空，则返回p
c.insert(p, il)			il是一个花括号包围的元素值列表。将这些给定值插入到迭代器p指向的元素之前。返回指向
						新添加的第一个元素的迭代器；若列表为空，则返回p
-----------------------------------------------------------------------------------------------------

11. 当调用push或insert成员函数时，我们将元素类型的对象传递给它们，这些对象被拷贝到容器中。而当我们调用
一个emplace成员函数时，则是将参数传递给元素类型的构造函数。emplace成员使用这些参数在容器管理的内存空间
中直接构造元素。
*/
