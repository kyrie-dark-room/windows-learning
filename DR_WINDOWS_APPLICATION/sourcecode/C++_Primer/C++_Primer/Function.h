#pragma once
/*
------------------------------------------------------------------------------------------------------
										信息点
------------------------------------------------------------------------------------------------------
	1. 熟悉C的程序员常常使用指针类型的形参访问函数外部的对象。在C++语言中，建议使用引用类型的形参替代
	指针。
	2.如果函数无须改变引用形参的值，最好将其声明为常量引用。
	3.当用实参初始化参数时会忽略掉顶层const。换句话说，形参顶层const被忽略掉了。当形参有顶层const时，
	传给它常量对象或者非常量对象都是可以的。
	4.我们可以使用非常量初始化一个底层const对象，但是反过来不行。

	5.数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响，这两个性质分别是：
	  （1）不允许拷贝数组；
	  （2）使用数组时（通常）会将其转换成指针。
	  实例：
	    void print(const int*);
		void print(const int[]);
		void print(const int[10]);
		// 尽管形式不同，但上面的三个函数是等价的：每个函数的唯一形参都是const int*类型的。
	6. 因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供
	一些额外的信息。管理指针形参有三种常用的技术。
	  （1）使用标记指定数组长度
			要求数组本身包含一个结束标记，使用这种方法的典型示例是C风格字符串。
	  （2）使用标准库规范
			传递指向数组首元素和尾元素的指针，这种方法受到了标准库技术的启发。
	  （3）显式传递一个表示数组大小的形参
			专门定义一个表示数组大小的形参，在C程序和过去的C++程序中常常使用这种方法。
	7. 数组引用形参
		// 形参是数组的引用，维度是类型的一部分,&arr两端的括号必不可少
		void print(int (&arr)[10])
		{
			for (auto elem: arr)
			cout << elem << endl;
		}
	8. main函数的参数
		int main(int argc, char* argv[]){ ... }
	9. 含有可变形参的函数】
	  （1）initializer_list形参
			如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用某种特种类型的值的数组。
			initializer_list是一种标准库类型，用于表示某种特定类型的值的数组，和vector不一样的是，它
			对象中的元素永远是常量值，我们无法改变其对象中元素的值。
	  （2）可变参数模板
	  （3）省略符形参
			省略符形参是为了便于C++程序访问某些特殊的C代码而设置的，这些代码使用了名为varargs的C标准库
			功能。通常，省略符形参不应用于其他目的。省略符形参只出现在形参列表的最后一个位置，它的形式
			无外乎以下两种：
			void foo(parm_list, ...);
			void foo(...);
	10. 我们允许mian函数没有return语句直接结束。如果控制到达了main函数的结尾处而且没有return语句，编译器
		将隐式地插入一条返回0的return语句。
	11. 为了使返回值与机器无关，cstdlib头文件定义了两个预处理变量，我们可以使用这两个变量分别表示成功与失败：
	    example:
		int main()
		{
			if (some_failure)
				return EXIT_FAILURE;    // 定义在cstdlib头文件中
			else
				return EXIT_SUCCESS;	// 定义在cstdlib头文件中
		}
	12. 尾置返回类型（C++11）
		任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效，比如返回类型是数组
		的指针或者数组的引用。尾置返回类型跟在形参列表后面并以一个 -> 符号开头。为了表示函数真正的返回类型
		跟在形参列表之后，我们在本应该出现返回类型的地方放置一个auto:
		example:
		// func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组
		auto func(int i) -> int (*)[10];
	13. 重载与作用域
		如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。在不同的作用域中无法重载函数名。
		在C++语言中，名字查找发生在类型检查之前。编译器一旦在当前作用域中找到了所需的名字，编译器就会忽略
		掉外层作用域中的同名实体。剩下的工作就是检查函数调用是否有效了。
	14. 我们可以为一个或多个形参定义默认值，不过需要注意的是，一旦某个形参被赋予了默认值，它后面的所有
		形参都必须有默认值。
	15. 在函数的返回类型前面加上关键字inline，这样就可以将它声明成内联函数了。内联说明只是向编译器发出的
		一个请求，编译器可以选择忽略这个请求。
	16. constexpr函数是指能用于常量表达式的函数。定义constexpr函数的方法与其他函数类似，不过要遵循几项约定：
		函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句。
		example:
		constexpr int new_sz(){ return 42;}
		constexpr int foo = new_sz();   正确：foo是一个常量表达式
		执行该初始化任务时，编译器把对constexpr函数的调用替换成其结果值。为了能在编译过程中随时展开，
		constexpr函数被隐式地指定为内联函数。
	17. 调试帮助
		（1）assert预处理宏
			assert是一种预处理宏。所谓预处理宏其实是一个预处理变量，它的行为有点类似于内联函数。assert
			宏使用一个表达式作为它的条件：
			assert(expr);
			首先对expr求值，如果表达式为假（即 0），assert输出信息并终止程序的执行。如果表达式为真（即非0），
			assert什么也不做。
		（2）NDEBUG
			assert的行为依赖于一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG，则assert什么也不做。默认状态下
			没有定义NDEBUG，此时assert将执行运行时检查。
			除了用于assert外，也可以使用NDEBUG编写自己的条件调试代码：
			example：
			void print(const int ia[], size_t size)
			{
				#ifndef NDEBUG
					// _ _func_ _ 是编译器定义的一个局部静态变量，用于存放函数的名字
					cerr << _ _func_ _ << ":array size is " << size << endl;
				#endif
			}
		（3）除了C++编译器定义的_ _func_ _之外，预处理器还定义了另外4个对于程序调试很有用的名字：
			_ _FILE_ _存放文件名的字符串字面值
			_ _LINE_ _存放当前行号的整形字面值
			_ _TIME_ _存放文件编译时间的字符串字面值
			_ _DATE_ _存放文件编译日期的字符串字面值
	18. 实参类型转换
		为了确定最佳匹配，编译器将是参类型到形参类型的转换划分成几个等级，具体排序如下所示：
		（1）精确匹配，包括以下情况
		   ・实参类型和形参类型相同
		   ・实参从数组类型或函数类型转换成对应的指针类型
		   ・向实参添加顶层const或者从实参中删除顶层const
		（2）通过const转换实现的匹配
		（3）通过类型提升实现的匹配
		（4）通过算数类型转换或指针转换实现的匹配
		（5）通过类类型转换实现的匹配
	19. 使用函数指针注意
		（1）当我们把函数名作为一个值使用时，该函数自动地转换成指针。
		（2）此外，我们还能直接使用指向函数的指针调用该函数，无须提前解引用指针。
		（3）在指向不同函数类型的指针间不存在转换原则。
------------------------------------------------------------------------------------------------------
*/
