#pragma once
/*
1.与仅需几个程序员就能开发完成的系统相比，大规模编程对程序设计语言的要求更高。大规模应用程序的特殊要求包括：
	・在独立开发的子系统之间协同处理错误的能力。
	・使用各种库（可能包含独立开发的库）进行协同开发的能力。
	・对比较复杂的应用概念建模的能力。
2.异常的处理
	异常处理（exception handling）机制允许程序中独立开发的部分能够在运行时就出现的问题进行通信并做出相应的处理。
	1）在C++语言中我们通过抛出（throwing）一条表达式来引发（raised）一个异常。被抛出的表达式的类型以及当前的调用链共同决定了哪段处理代码（handler）
	  将被用来处理该异常。被选中的处理代码是在调用链中与抛出对象类型匹配的最近的处理代码。其中，根据抛出对象的类型和内容，程序的异常抛出部分将会告知
	  异常处理部分到底发生了什么错误。
	2）当执行一个throw时，跟在throw后面的语句将不再被执行。相反，程序的控制权从throw转移到与之匹配的catch模块。该catch可能是同一个函数中的局部catch，
	  也可能位于直接或间接调用了发生异常的函数的另一个函数中。控制权从一处转移到另一处，这有两个重要的含义：
		・沿着调用链的函数可能会提早退出。
		・一旦程序开始执行异常处理代码，则沿着调用链创建的对象将被销毁。
	3）当抛出一个异常后，程序暂停当前函数的执行过程并立即开始寻找与异常匹配的catch子句。当throw出现在一个try语句块（try block）内时，检查与该try块关联的
	  catch子句。如果找到了匹配的catch，就是用该catch异常处理。如果这一步没找到匹配的catch且该try语句嵌套在其他try快中，则继续检查与外层try匹配的catch子句。
	  如果还是找不到匹配的catch，则退出当前的函数，在调用当前函数的外层函数中继续寻找，以此类推。
	4）上述过程被称为栈展开（stack unwinding）过程。栈展开过程沿着嵌套函数的调用链不断查找，直到找到了与异常匹配的catch子句为止；或者也可能一直没找到匹配
      的catch，则退出主函数后查找过程终止。
	   如果没找到匹配的catch子句，程序将退出。因为异常通常被认为是妨碍程序正常执行的事件，所以一旦引发了某个异常，就不能对它置之不理。当找不到匹配的catch时，
	  程序将调用标准库terminate，顾名思义，terminate负责终止程序的执行过程。
	5）出于栈展开可能使用析构函数的考虑，析构函数不应该抛出不能被它自身处理的异常。在实际的编程过程中，因为析构函数仅仅是释放资源，所以它不太可能抛出异常。
	  所有标准库类型都能确保它们的析构函数不会引发异常。
	   在栈展开的过程中，运行类类型的局部对象的析构函数。因为这些析构函数是自动执行的，所以它们不应该抛出异常。一旦在栈展开的过程中析构函数抛出了异常，并且
	  析构函数自身没有能捕获到该异常，则程序将被终止。
	6）异常对象（exception object）是一种特殊的对象，编译器使用异常抛出表达式来对异常对象进行拷贝初始化。因此，throw语句中的表达式必须拥有完全类型。而且如果
	  该表达式是类类型的话，则相应的类必须含有一个可访问的析构函数和一个可访问的拷贝或移动构造函数。如果该表达式是数组类型或函数类型，则表达式将被转换成与之
	  对应的指针类型。
	   异常对象位于由编译器管理的空间中，编译器确保无论最终调用的是哪个catch子句都能访问该空间。当异常处理完毕后，异常对象被销毁。
	   当我们抛出一条表达式时，该表达式的静态编译时类型决定了异常对象的类型。
	7）catch子句（catch clause）中的异常声明（exception declaration）看起来像是只包含一个形参的函数形参列表。声明的类型决定了处理代码所能捕获的异常类型。这个
	  类型必须是完全类型，它可以是左值引用，但不能是右值引用。
	   最后一点需要注意的是，异常声明的静态类型将决定catch语句所能执行的操作。如果catch的参数是基类类型，则catch无法使用派生类特有的任何成员。
	   通常情况下，如果catch接受的异常与某个继承体系有关，则最好将该catch的参数定义成引用类型。
	8）与实参和形参的匹配规则相比，异常和catch异常声明的匹配规则受到更多限制。此时，绝大多数类型转换都不被允许，除了一些极细小的差别之外，要求异常的类型和catch
	  声明的类型都是精确匹配的：
		・允许从非常量向常量的类型转换，也就是说，一条非常量对象的throw语句可以匹配一个接受常量引用的catch语句。
		・允许从派生类向基类的类型转换。
		・数组被转换成指向数组（元素）类型的指针，函数被转换成指向该函数类型的指针。
	  除此之外，包括标准算术类型转换和类类型转换在内，其他所有转换规则都不能在匹配的catch的过程中使用。
	9）有时，一个单独的catch语句不能完整地处理某个异常。在执行了某些矫正操作之后，当前的catch可能会决定由调用链更上一层的函数接着处理异常。一条catch语句通过重新抛出（rethrowing）
	  的操作将异常传递给另外一个catch语句。这里的重新抛出仍然是一条throw语句，只不过不包含任何表达式。
	   throw;
	   空的throw语句只能出现在catch语句或catch语句直接或间接调用的函数之内。如果在处理代码之外的区域遇到了空throw语句，编译器将调用terminate。
	10）为了一次性捕获所有异常，我们使用省略号作为异常声明，这样的处理代码称为捕获所有异常（catch-all）的处理代码，形如catch(...)。一条捕获所有异常的语句可以与任意类型的异常匹配。
	   catch(...)通常与重新抛出语句一起使用，其中catch执行当前局部能完成的工作，随后重新抛出异常：
			void manip(){
				try{
					// 这里的操作将引发并抛出一个异常
				}
				catch(...){
					// 处理异常的某些特殊操作
					throw;
				}
			}
	11）要想处理构造函数初始值抛出的异常，我们必须将构造函数写成函数try语句块（也称为函数测试块，function try block）的形式。函数try语句块使得一组catch语句既能处理构造函数体
	  （或析构函数体），也能处理构造函数的初始化过程（或析构函数的析构过程）。举个例子，我们可以把Blob的构造函数置于一个函数try语句块中。
			template <typename T>
			Blob<T>::Blob(std::initializer_list<T> il) try : data(std::make_shared<std::vector<T>> (il)) {
				// 空函数体
			}catch(const std::bad_alloc &e){
				handle_out_of_memory(e);
			}
		处理构造函数初始值异常的唯一方法是将构造函数写成函数try语句块。
	12）noexcept异常说明
		对于用户及编译器来说，预先知道某个函数不会抛出异常显然大有裨益。首先，知道函数不会抛出异常有助于简化调用该函数的代码；其次，如果编译器确认函数不会抛出异常，
	   它就能执行某些特殊的优化操作，而这些优化操作并不适用于可能出错的代码。
	    在C++11新标准中，我们可以通过noexcept说明（noexcept specification）指定某个函数不会抛出异常。其形式是关键字noexcept紧跟在函数的参数列表后面，用以标识该函数
	   不会抛出异常：
			void recoup(int) noexcept;	// 不会抛出异常
		我们说recoup做了不抛出说明（nonthrowing specification）。
	    对于一个函数来说，noexcept说明要么出现在该函数的所有声明语句和定义语句中，要么一次也不出现。该说明应该在函数的尾置返回类型之前。我们也可以在函数指针的声明和定义中
	   指定noexcept。在typedef或类型别名中则不能出现noexcept。在成员函数中，noexcept说明符需要跟在const及引用限定符之后，而在final、override或虚函数的=0之前。
	    读者需要清楚的一个事实是编译器并不会在编译时检查noexcept说明。一旦一个noexcept函数抛出了异常，程序就会调用terminate以确保遵守不在运行时抛出异常的承诺。上述过程
	   对是否执行栈展开未作约定。
	13）早期的C++版本设计了一套更加详细的异常说明方案，该方案使得我们可以指定某个函数可能抛出的异常类型。函数可以指定一个关键字throw，在后面跟上括号括起来的异常类型列表。
	   throw说明符所在的位置与新版本C++中noexcept所在的位置相同。
	    上述使用throw的异常说明方案在C++11新版本中已经被取消了。然而尽管如此，它还是一个重要的用处。如果函数被设计为是throw()的，则意味着该函数将不会抛出异常：
			void recoup(int) noexcept;	// recoup不会抛出异常
			void recoup(int) throw();	// 等价的声明
		noexcept说明符接受一个可选的实参，该实参必须能转换为bool类型：如果实参为true，则函数不会抛出异常；如果实参是false，则函数可能抛出异常。
	14）noexcept说明符的实参常常与noexcept运算符（noexcept operator）混合使用。noexcept运算符是一个一元运算符，它的返回值是一个bool类型的右值常量表达式，用于表示给定的表达式
	   是否会抛出异常。
	    更普通的形式是：
			noexcept(e)
		当e调用的所有函数都做了不抛出说明且e本身不包含有throw语句时，上述表达式为true；否则noexcept(e)返回false。
	15）异常说明与指针、虚函数和拷贝控制
		函数指针及该指针所指的函数必须具有一致的异常说明。也就是说，如果我们为某个指针做了不抛出异常的声明，则该指针将只能指向不抛出异常的函数。相反，如果我们显式或隐式地
	   说明了指针可能抛出异常，则该指针可以指向任何函数，即使是承诺了不抛出异常的函数也可以；
	    如果一个虚函数承诺了它不会抛出异常，则后续派生出来的虚函数也必须做出同样的承诺；与之相反，如果基类的虚函数允许抛出异常，则派生类的对应函数即可以允许抛出异常，也可以
	   不允许抛出异常；
	    当编译器合成拷贝控制成员时，同时也生成一个异常说明。如果对所有成员和基类的所有操作都承诺了不会抛出异常，则合成的成员是noexcept的。如果合成成员调用的任意一个函数可能
	   抛出异常，则合成的成员是noexcept(false)。而且，如果我们定义了一个析构函数但是没有为它提供异常说明，则编译器将合成一个。合成的异常说明将与假设由编译器为类合成析构函数时
	   所得的异常说明一致。
*/