#pragma once
/*
1.与仅需几个程序员就能开发完成的系统相比，大规模编程对程序设计语言的要求更高。大规模应用程序的特殊要求包括：
	・在独立开发的子系统之间协同处理错误的能力。
	・使用各种库（可能包含独立开发的库）进行协同开发的能力。
	・对比较复杂的应用概念建模的能力。
2.异常的处理
	异常处理（exception handling）机制允许程序中独立开发的部分能够在运行时就出现的问题进行通信并做出相应的处理。
	1）在C++语言中我们通过抛出（throwing）一条表达式来引发（raised）一个异常。被抛出的表达式的类型以及当前的调用链共同决定了哪段处理代码（handler）
	  将被用来处理该异常。被选中的处理代码是在调用链中与抛出对象类型匹配的最近的处理代码。其中，根据抛出对象的类型和内容，程序的异常抛出部分将会告知
	  异常处理部分到底发生了什么错误。
	2）当执行一个throw时，跟在throw后面的语句将不再被执行。相反，程序的控制权从throw转移到与之匹配的catch模块。该catch可能是同一个函数中的局部catch，
	  也可能位于直接或间接调用了发生异常的函数的另一个函数中。控制权从一处转移到另一处，这有两个重要的含义：
		・沿着调用链的函数可能会提早退出。
		・一旦程序开始执行异常处理代码，则沿着调用链创建的对象将被销毁。
	3）当抛出一个异常后，程序暂停当前函数的执行过程并立即开始寻找与异常匹配的catch子句。当throw出现在一个try语句块（try block）内时，检查与该try块关联的
	  catch子句。如果找到了匹配的catch，就是用该catch异常处理。如果这一步没找到匹配的catch且该try语句嵌套在其他try快中，则继续检查与外层try匹配的catch子句。
	  如果还是找不到匹配的catch，则退出当前的函数，在调用当前函数的外层函数中继续寻找，以此类推。
	4）上述过程被称为栈展开（stack unwinding）过程。栈展开过程沿着嵌套函数的调用链不断查找，直到找到了与异常匹配的catch子句为止；或者也可能一直没找到匹配
      的catch，则退出主函数后查找过程终止。
	   如果没找到匹配的catch子句，程序将退出。因为异常通常被认为是妨碍程序正常执行的事件，所以一旦引发了某个异常，就不能对它置之不理。当找不到匹配的catch时，
	  程序将调用标准库terminate，顾名思义，terminate负责终止程序的执行过程。
	5）出于栈展开可能使用析构函数的考虑，析构函数不应该抛出不能被它自身处理的异常。在实际的编程过程中，因为析构函数仅仅是释放资源，所以它不太可能抛出异常。
	  所有标准库类型都能确保它们的析构函数不会引发异常。
	   在栈展开的过程中，运行类类型的局部对象的析构函数。因为这些析构函数是自动执行的，所以它们不应该抛出异常。一旦在栈展开的过程中析构函数抛出了异常，并且
	  析构函数自身没有能捕获到该异常，则程序将被终止。
	6）异常对象（exception object）是一种特殊的对象，编译器使用异常抛出表达式来对异常对象进行拷贝初始化。因此，throw语句中的表达式必须拥有完全类型。而且如果
	  该表达式是类类型的话，则相应的类必须含有一个可访问的析构函数和一个可访问的拷贝或移动构造函数。如果该表达式是数组类型或函数类型，则表达式将被转换成与之
	  对应的指针类型。
	   异常对象位于由编译器管理的空间中，编译器确保无论最终调用的是哪个catch子句都能访问该空间。当异常处理完毕后，异常对象被销毁。
	   当我们抛出一条表达式时，该表达式的静态编译时类型决定了异常对象的类型。
	7）catch子句（catch clause）中的异常声明（exception declaration）看起来像是只包含一个形参的函数形参列表。声明的类型决定了处理代码所能捕获的异常类型。这个
	  类型必须是完全类型，它可以是左值引用，但不能是右值引用。
	   最后一点需要注意的是，异常声明的静态类型将决定catch语句所能执行的操作。如果catch的参数是基类类型，则catch无法使用派生类特有的任何成员。
	   通常情况下，如果catch接受的异常与某个继承体系有关，则最好将该catch的参数定义成引用类型。
	8）与实参和形参的匹配规则相比，异常和catch异常声明的匹配规则受到更多限制。此时，绝大多数类型转换都不被允许，除了一些极细小的差别之外，要求异常的类型和catch
	  声明的类型都是精确匹配的：
		・允许从非常量向常量的类型转换，也就是说，一条非常量对象的throw语句可以匹配一个接受常量引用的catch语句。
		・允许从派生类向基类的类型转换。
		・数组被转换成指向数组（元素）类型的指针，函数被转换成指向该函数类型的指针。
	  除此之外，包括标准算术类型转换和类类型转换在内，其他所有转换规则都不能在匹配的catch的过程中使用。
	9）有时，一个单独的catch语句不能完整地处理某个异常。在执行了某些矫正操作之后，当前的catch可能会决定由调用链更上一层的函数接着处理异常。一条catch语句通过重新抛出（rethrowing）
	  的操作将异常传递给另外一个catch语句。这里的重新抛出仍然是一条throw语句，只不过不包含任何表达式。
	   throw;
	   空的throw语句只能出现在catch语句或catch语句直接或间接调用的函数之内。如果在处理代码之外的区域遇到了空throw语句，编译器将调用terminate。
	10）为了一次性捕获所有异常，我们使用省略号作为异常声明，这样的处理代码称为捕获所有异常（catch-all）的处理代码，形如catch(...)。一条捕获所有异常的语句可以与任意类型的异常匹配。
	   catch(...)通常与重新抛出语句一起使用，其中catch执行当前局部能完成的工作，随后重新抛出异常：
			void manip(){
				try{
					// 这里的操作将引发并抛出一个异常
				}
				catch(...){
					// 处理异常的某些特殊操作
					throw;
				}
			}
	11）要想处理构造函数初始值抛出的异常，我们必须将构造函数写成函数try语句块（也称为函数测试块，function try block）的形式。函数try语句块使得一组catch语句既能处理构造函数体
	  （或析构函数体），也能处理构造函数的初始化过程（或析构函数的析构过程）。举个例子，我们可以把Blob的构造函数置于一个函数try语句块中。
			template <typename T>
			Blob<T>::Blob(std::initializer_list<T> il) try : data(std::make_shared<std::vector<T>> (il)) {
				// 空函数体
			}catch(const std::bad_alloc &e){
				handle_out_of_memory(e);
			}
		处理构造函数初始值异常的唯一方法是将构造函数写成函数try语句块。
	12）noexcept异常说明
		对于用户及编译器来说，预先知道某个函数不会抛出异常显然大有裨益。首先，知道函数不会抛出异常有助于简化调用该函数的代码；其次，如果编译器确认函数不会抛出异常，
	   它就能执行某些特殊的优化操作，而这些优化操作并不适用于可能出错的代码。
	    在C++11新标准中，我们可以通过noexcept说明（noexcept specification）指定某个函数不会抛出异常。其形式是关键字noexcept紧跟在函数的参数列表后面，用以标识该函数
	   不会抛出异常：
			void recoup(int) noexcept;	// 不会抛出异常
		我们说recoup做了不抛出说明（nonthrowing specification）。
	    对于一个函数来说，noexcept说明要么出现在该函数的所有声明语句和定义语句中，要么一次也不出现。该说明应该在函数的尾置返回类型之前。我们也可以在函数指针的声明和定义中
	   指定noexcept。在typedef或类型别名中则不能出现noexcept。在成员函数中，noexcept说明符需要跟在const及引用限定符之后，而在final、override或虚函数的=0之前。
	    读者需要清楚的一个事实是编译器并不会在编译时检查noexcept说明。一旦一个noexcept函数抛出了异常，程序就会调用terminate以确保遵守不在运行时抛出异常的承诺。上述过程
	   对是否执行栈展开未作约定。
	13）早期的C++版本设计了一套更加详细的异常说明方案，该方案使得我们可以指定某个函数可能抛出的异常类型。函数可以指定一个关键字throw，在后面跟上括号括起来的异常类型列表。
	   throw说明符所在的位置与新版本C++中noexcept所在的位置相同。
	    上述使用throw的异常说明方案在C++11新版本中已经被取消了。然而尽管如此，它还是一个重要的用处。如果函数被设计为是throw()的，则意味着该函数将不会抛出异常：
			void recoup(int) noexcept;	// recoup不会抛出异常
			void recoup(int) throw();	// 等价的声明
		noexcept说明符接受一个可选的实参，该实参必须能转换为bool类型：如果实参为true，则函数不会抛出异常；如果实参是false，则函数可能抛出异常。
	14）noexcept说明符的实参常常与noexcept运算符（noexcept operator）混合使用。noexcept运算符是一个一元运算符，它的返回值是一个bool类型的右值常量表达式，用于表示给定的表达式
	   是否会抛出异常。
	    更普通的形式是：
			noexcept(e)
		当e调用的所有函数都做了不抛出说明且e本身不包含有throw语句时，上述表达式为true；否则noexcept(e)返回false。
	15）异常说明与指针、虚函数和拷贝控制
		函数指针及该指针所指的函数必须具有一致的异常说明。也就是说，如果我们为某个指针做了不抛出异常的声明，则该指针将只能指向不抛出异常的函数。相反，如果我们显式或隐式地
	   说明了指针可能抛出异常，则该指针可以指向任何函数，即使是承诺了不抛出异常的函数也可以；
	    如果一个虚函数承诺了它不会抛出异常，则后续派生出来的虚函数也必须做出同样的承诺；与之相反，如果基类的虚函数允许抛出异常，则派生类的对应函数即可以允许抛出异常，也可以
	   不允许抛出异常；
	    当编译器合成拷贝控制成员时，同时也生成一个异常说明。如果对所有成员和基类的所有操作都承诺了不会抛出异常，则合成的成员是noexcept的。如果合成成员调用的任意一个函数可能
	   抛出异常，则合成的成员是noexcept(false)。而且，如果我们定义了一个析构函数但是没有为它提供异常说明，则编译器将合成一个。合成的异常说明将与假设由编译器为类合成析构函数时
	   所得的异常说明一致。
	16）异常类层次
																	exception
											bad_cast		runtime_error		logic_error		bad_alloc
																|					|
																|					|
										overflow_error----------|					|----------domain_error
									   underflow_error----------|					|----------invalid_argument
										   range_error----------|					|----------out_of_range
																					|----------length_error
		类型exception仅仅定义了拷贝构造函数、拷贝赋值运算符、一个虚析构函数和个名为what的虚成员。其中what函数返回一个const char*，该指针指向一个以null结尾
	   的字符数组，并且确保不会抛出任何异常。
	    类exception、bad_cast和bad_alloc定义了默认构造函数。类runtime_error和logic_error没有默认构造函数，但是有一个可以接受C风格字符串或者标准库string类型实参的
	   构造函数，这些实参负责提供关于错误的更多信息。
	    在这些类中，what负责返回用于初始化异常对象的信息。因为what是虚函数，所以当我们捕获基类的引用时，对what函数的调用将执行与异常对象动态类型对应的版本。
3.命名空间
	1）大型程序往往会使用多个独立开发的库，这些库又会定义大量的全局名字，如类、函数和模板等。当应用程序用到多个供应商提供的库时，不可避免地会发生某些名字相互冲突的情况
	  。多个库将名字放置在全局命名空间中将引发命名空间污染（namespace pollution）。
	2）命名空间（namespace）为防止名字冲突提供了更加可控的机制。命名空间分割了全局命名空间，其中每个命名空间是一个作用域。通过在某个命名空间中定义库的名字，库的作者（以及用户）
	  可以避免全局名字固有的限制。
	3）一个命名空间的定义包含两部分：首先是关键字namespace，随后是命名空间的名字。在命名空间名字后面是一系列由花括号括起来的声明和定义。命名空间作用域后面无需分号。
	4）命名空间可以定义在几个不同的部分，这一点与其他作用域不太一样。命名空间的定义可以不连续的特性使得我们可以将几个独立的接口和实现文件组成一个命名空间。此时，
	  命名空间的组织方式类似于我们管理自定义类及函数的方式：
	   ・命名空间的一部分成员的作用是定义类，以及声明作为类接口的函数及对象，则这些成员应该置于头文件中，这些头文件将被包含在使用了这些成员的文件中。
	   ・命名空间成员的定义部分则置于另外的源文件中。
	5）全局作用域中定义的名字（即在所有类、函数及命名空间之外定义的名字）也就是定义在全局命名空间（global namespace）中。全局命名空间以隐式地方式声明，并且在所有程序中
	  都存在。全局作用域中定义的名字被隐式地添加到全局命名空间中。
	   作用域运算符同样可以用于全局作用域的成员，因为全局作用域是隐式的，所以它并没有名字。下面的形式
	   ::member_name
	   表示全局命名空间中的一个成员。
	6）C++11新标准引入了一种新的嵌套命名空间，称为内敛命名空间（inline namespace）。和普通的嵌套命名空间不同，内联命名空间中的名字可以被外城命名空间直接使用。也就是说，我们
	  无须在内联命名空间的名字前添加表示该命名空间的前缀，通过外层命名空间的名字就可以直接访问它。关键字inline必须出现在命名空间第一次定义的地方，后续再打开命名空间的时候
	  可以写inline，也可以不写。
	7）未命名的命名空间（unnamed namespace）是指关键字namespace后紧跟花括号括起来的一系列声明语句。未命名的命名空间中定义的变量拥有静态生命周期：它们在第一次使用前创建，并且
	  知道程序结束才销毁。一个未命名的命名空间可以在某个给定的文件内不连续，但是不能跨越多个文件。
	8）在文件中进行静态声明的做法已经被C++标准取消了，现在的做法是使用未命名的命名空间。
	9）命名空间的别名
		命名空间的别名（namespace alias）使得我们可以为命名空间的名字设定一个短得多的同义词。
		例如：
			namespace cplusplus_primer { ...};
			我们可以为其设定一个短得多的同义词
			namespace primer = cplusplus_primer;
		一个命名空间可以有好几个同义词或别名，所有别名都与命名空间原来的名字等价。
	10）using指示使得某个特定的命名空间中所有的名字都可见，这样我们就无须再为它们添加任何前缀限定符了。简写的名字从using指示开始，一直到using指示所在的作用域结束都能实现。
		using namespace A;
	11）相比于使用using指示，在程序中对命名空间的每个成员分别使用using声明效果更好，这么做可以减少注入到命名空间中的名字数量。using声明引起的二义性问题在声明处就能发现，
	  无须等到使用名字的地方，这显然对检测并修改错误大有益处。
	12）考虑下面这个简单的程序：
			std::string s;
			std::cin >> s;
		如我们所知，该调用等价于
			operator>>(std::cin, s);
		operator>>函数定义在标准库string中，string又定义在命名空间std中。但是我们不用std::限定符和using声明就可以调用operator>>。
		对于命名空间中名字的隐藏规则来说有一个重要的例外，它使得我们可以直接访问输出运算符。这个例外是，当我们给函数传递一个类类型的对象时，除了在常规的作用域查找外
	  还会查找实参类所属的命名空间。这一例外对于传递类的引用或指针的调用同样有效。
	13）对于move和forward来说，冲突很多但是大多数是无意的，这一特点解释了为什么我们建议最好使用它们的带限定语的完整版本的原因。通过书写std::move而非move,我们就能明确
	  地知道想要使用的函数的标准库版本。
	14）当类声明了一个友元时，该友元声明并没有使得友元本身可见。然而，一个另外的未声明的类或函数如果第一次出现在友元声明中，则我们认为它是最近的外层命名空间的成员。这条
	  规则与实参相关的查找规则结合在一起将产生意想不到的效果。
		namespace A {
			class C {
				// 两个友元，在友元声明之外没有其他的声明
				// 这些函数隐式地称为命名空间A的成员
				friend void f2();			// 除非另有声明，否则不会被找到
				frient void f(const C&);	// 根据实参相关的查找规则可以被找到
			};
		}
	  此时，f和f2都是命名空间A的成员。即使f不存在其他声明，我们也能通过实参相关的查找规则调用f: 
		int main()
		{
			A::C cobj;
			f(cobj);	// 正确：通过在A::C中的友元声明找到A::f
			f2();		// 错误：A::f2没有被声明
		}
	15）命名空间对函数的匹配过程有两方面的影响。
			a. 其中一个影响非常明显：using声明或指示能将某些函数添加到候选函数集。
			b. 另外一个影响则比较微妙：对于接受类类型实参的函数来说，起名字查找将在实参类所属的命名空间中进行。这条规则对于我们如何确定候选函数集同样也有影响。
	16）与using声明的不同的是，对于using指示来说，引入一个与已有函数形参列表完全相同的函数并不会产生错误。此时，只要我们指明调用的是命名空间中的函数版本还是当前
	  作用域的版本即可。
4.多重继承与虚继承
	1）多重继承（multiple inheritance）是指从多个直接基类中产生派生类的能力。多重继承的派生类继承了所有父类的属性。尽管概念上非常简单，但是多个基类相互交织产生
	  的细节可能会带来错综复杂的设计问题与实现问题。
	2）在派生类的派生列表中可以包含多个基类：
		class Bear : public ZooAnimal {};
		class Pada : public Bear, public Endangered{};
		每个基类包含一个可选的访问说明符。一如既往，如果访问说明符被忽略掉，则关键字class对应的默认访问说明符是private，关键字struct对应的是public。
	3）对于派生类能够继承的基类个数，C++没有进行特殊规定；但是在某个给定的派生类列表中，同一个基类只能出现一次。
	4）在多重继承关系中，派生类的对象包含有每个基类的子对象。构造一个派生类的对象将同时构造并初始化它的所有基类子对象。多重继承的派生类的构造函数初始值也只能初始化它的
	  直接基类。其中基类的构造顺序与派生列表中基类的出现顺序保持一致，而与派生类构造函数初始值列表中基类的顺序无关。
	5）在C++新标准中，允许派生类从它的一个或几个基类中继承构造函数。但是如果从多个基类中继承了相同的构造函数，则程序将产生错误：
		struct Base1{	
			Base1() = default;
			Base1(const std::string&);
			Base1(std::shared_ptr<int>);
		};
		struct Base2{
			Base2() = default;
			Base2(const std::string&);
			Base2(int);
		};
		// 错误：D1试图从两个基类中都继承D1::D1(const string&)
		struct D1: public Base1, public Base2{
			using Base1::Base1;		// 从Base1继承构造函数
			using Base2::Base2;		// 从Base2继承构造函数
		};
	  如果一个类从它的多个基类中继承了相同的构造函数，则这个类必须为该构造函数定义它自己的版本：
	    struct D2: public Base1, public Base2{
			using Base1::Base1;		// 从Base1继承构造函数
			using Base2::Base2;		// 从Base2继承构造函数
			// D2必须自定义一个接受string的构造函数
			D2(const string &s): Base1(s), Base2(s) { }
			D2() = default;			// 一旦D2定义了它自己的构造函数，则必须出现
		};
	6）编译器不会在派生类向基类的几种转换中进行比较和选择，因为在它看来转换到任意一种基类都一样好。
	7）当一个类拥有多个基类时，有可能出现派生类从两个或更多基类中继承了同名成员的情况。此时，不加前缀限定符直接使用该名字将引发二义性。要想避免潜在的二义性，最好
	  的办法是在派生类中为该函数定义一个新版本来解决二义性。
	8）尽管在派生列表中同一个基类只能出现一次，但实际上派生类可以多次继承同一个类。派生类可以通过它的两个直接基类分别继承同一个间接基类，也可以直接继承某个基类，
	  然后通过另一个基类再一次间接继承该类。
	9）在C++语言中我们通过虚继承（virtual inheritance）的机制解决上述问题。虚继承的目的是令某个类做出声明，承诺愿意共享它的基类。其中，共享的基类子对象称为虚基类（virtual base class）。
	  在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象。
	   虚派生只影响从指定了虚基类的派生类中进一步派生出的类，它不会影响派生类本身。
	10）我们指定虚基类的方式是在派生列表中添加关键字virtual：
			// 关键字public和virtual的顺序随意
			class Raccoon：public virtual ZooAnimal {};
			class Bear：virtual public ZooAnimal {}
		Virtual说明符表明了一种愿望，即在后续的派生类当中共享虚基类的同一份实例。至于什么样的类能够作为虚基类并没有特殊规定。
	11）不论基类是不是虚基类，派生类对象都能被可访问基类的指针或引用操作。、
	12）因为在每个共享的虚基类中只有唯一一个共享的子对象，所以该基类的成员可以被直接访问，并且不会产生二义性。此外，如果虚基类的成员只被一条派生路径覆盖，则我们
	  仍然可以直接访问这个被覆盖的成员。但是如果成员被多余一个基类覆盖，则一般情况下派生类必须为该成员自定义一个新的版本。
	13）在虚派生中，虚基类是由最底层的派生类初始化的。
	14）含有虚基类的对象的构造顺序与一般的顺序稍有区别：首先使用提供给最底层派生类构造函数的初始值初始化对象的虚基类子部分，接下来按照直接基类在派生列表中出现的
	  次序依次对其进行初始化。虚基类总是先于非虚基类构造，与它们在继承体系中的次序和位置无关。
	15）一个类可以有多个虚基类。此时，这些虚的子对象按照它们在派生列表中出现的顺序从左向右依次构造。合成的拷贝和移动构造函数按照完全相同的顺序执行，合成的赋值运算符中
	  的成员也按照该顺序赋值。

*/