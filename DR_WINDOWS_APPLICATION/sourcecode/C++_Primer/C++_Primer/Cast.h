#pragma once
/*
------------------------------------------------------------------------------------------------------
										命名的强制类型转换
------------------------------------------------------------------------------------------------------
1. 一个命名的强制类型转换具有如下形式：
    cast-name<type>(expression);
  （1）static_cast: 具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast
    实例：double slope = static_cast<double>(j)/i;
  （2）const_cast: const_cast只能改变运算对象的底层const
    实例：const char *pc;
	      char *p = const_cast<char*>(pc);
  （3）dynamic_cast: 支持运行时类型识别。
  （4）reinterpret_cast: 通常为运算对象的位模式提供较低层次上的重新解释。
    实例：int *ip;
	      char *pc = reinterpret_cast<char*>(ip);
		  我们必须牢记pc所指的真是对象是一个int而非字符，如果把pc当成普通的字符指针使用就可能
		  在运行时发生错误。
		  本质上依赖机器。要想安全地使用reinterpret_cast必须对涉及的类型和编译器实现转换的过程
		  都非常了解。
2. 在早期版本的C++语言中，显式地进行强制类型转换包含两种形式：
  （1）type(expr);    // 函数形式的强制类型转换
  （2）(type)expr;    // c语言风格的强制类型转换
------------------------------------------------------------------------------------------------------
*/
