#pragma once
/*
1. 重载运算符的概念
	（1）重载的运算符是具有特殊名字的函数：它们的名字由关键字operator和其后要定义的运算符号共同组成。
	和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。
	（2）重载运算符函数的参数数量与该运算符作用的运算对象数量一样多。如果一个运算符函数是成员函数，则
	它的第一个（左侧）运算对象绑定到隐式地this指针上，因此成员运算符函数的（显式）参数数量比运算符的
	运算对象总数少一个。
	（3）对于一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数：
		1）这一约定意味着当运算符作用于内置类型的运算对象时，我们无法改变该运算符的含义。
		2）我们可以重载大多数（但不是全部）运算符。
		3）我们只能重载已有的运算符，而无权发明新的运算符号。
		4）有四个符号（+、-、*、&）既是一元运算符也是二元运算符，所有这些运算符都能被重载，从参数的数量
		   我们可以推断到底定义的是哪种运算符。
		5）对于一个重载的运算符来说，其优先级和结合律与对应的内置运算符保持一致。
	（4）运算符
	-------------------------------------------------------------------------------------------------
	|											运算符                                              |
	-------------------------------------------------------------------------------------------------
	|		可以被重载的运算符																		|
	|		+	-	*	/	%	^	&	|	~	!	,	=	<	>	<=	>=	++	--	<<	>>	==	!=  |
	|		&&	||	+=	-=	/=	%=	^=	&=	!=	*=	<<=	>>=	[]	()	->	->*	new	new[] 				|
	|		delete delete[]																			|
	|		不能被重载的运算符																		|
	|		::	.*	.	?:																			|
	-------------------------------------------------------------------------------------------------
	（5）直接调用一个重载的运算符函数
		通常情况下，我们将运算符作用于类型正确的实参，从而以这种间接方式“调用”重载的运算符函数。然而，
	我们也能像调用普通函数一样直接调用运算符函数，先指定函数名字，而后传入数量正确、类型适当的实参：
		// 一个非成员运算符函数的等价调用
		data1 + data2;				// 普通的表达式
		operator+(data1，data2);	// 等价的函数调用
		我们像调用其他成员函数一样显式地调用成员运算符函数。具体做法是，首先指定运行函数的对象（或指针）
	的名字，然后使用点运算符（或箭头运算符）访问希望调用的函数：
		data1 += data2;				// 基于“调用”的表达式
		data1.operator+=(data2);	// 对成员运算符函数的等价调用
	（6）某些运算符不应该被重载
		1）某些运算符指定了运算对象求值的顺序。因为使用重载的运算符本质上是一次函数调用，所以这些关于
		运算对象求值顺序的规则无法应用到重载的运算符上。
		2）通常情况下，不应该重载逗号、取地址、逻辑与和逻辑或运算符。
	（7）选择作为成员或者非成员的准则：
		・赋值（=）、下标（[]）、调用（( )）和成员访问箭头（->）运算符必须是成员。
		・复合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值运算符略有不同。
		・改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员。
		・具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，因此它们通常
		  应该是普通的非成员函数。
2. 输入和输出运算符
	（1）通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符。
	（2）与iostream标准库兼容的输入输出运算符必须是普通的非成员函数，而不能是类的成员。否则，它们的左侧
	    运算对象将是我们的类的一个对象。
	（3）因此，如果我们希望为类自定义IO运算符，则必须将其定义成非成员函数。当然，IO运算符通常需要读写类
		的非公有数据成员，所以IO运算符一般被声明为友元。
	（4）输入运算符必须处理输入可能失败的情况，而输出运算符不需要。
	（5）当读取操作发生错误时，输入运算符应该负责从错误中恢复。
3. 算术和关系运算符
	（1）如果类同时定义了算术运算符和相关的符合赋值运算符，则通常情况下应该使用复合赋值来实现算术运算符。
	（2）重载等号运算符的设计准则：
		・如果一个类含有判断两个对象是否相等的操作，则它显然应该把函数定义成operator==而非一个普通的命名函数
		・如果类定义了operator==，则该运算符应该能判断一组给定的对象中是否含有重复数据。
		・通常情况下，相等运算符应该具有传递性。
		・如果类定义了operator==，则这个类也应该定义operator!=。
		・相等运算符和不相等运算符中的一个应该把工作委托给另一个，这意味着其中一个运算符应该负责实际比较工作，
		  而另一个运算符则只是调用那个真正工作的运算符。
	（3）如果存在唯一一种逻辑可靠的<定义，则应该考虑为这个类定义<运算符。如果类同时还包含==，则当且仅当
		<的定义和==产生的结果一致时才定义<运算符。
4. 赋值运算符
	（1）我们可以重载赋值运算符。不论形参的类型是什么，赋值运算符都必须定义为成员函数。
	（2）复合赋值运算符不非得是类的成员，不过我们还是倾向于把包括复合赋值在内的所有赋值运算都定义在类的内部。
5. 下标运算符
	（1）下标运算符必须是成员函数。
	（2）如果一个类包含下标运算符，则它通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并且
		返回常量引用。
6. 递增和递减运算符
	（1）定义递增和递减运算符的类应该同时定义前置版本和后置版本。这些运算符通常应该被定义成类的成员。
	（2）为了与内置版本保持一致，前置运算符应该返回递增或递减后对象的引用。
	（3）为了解决“普通的重载形式无法区分前置和后置运算符这两种情况”，后置版本接受一个额外的（不被使用）
		int类型的形参。当我们使用后置运算符时，编译器为这个形参提供一个值为0的实参。
	（4）为了与内置版本保持一致，后置运算符应该返回对象的原值（递增或递减之前的值），返回的形式是一个值而非引用。
7. 成员访问运算符
	（1）箭头运算符必须是类的成员。解引用运算符通常也是类的成员，尽管并非必须如此。
	（2）重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。
8. 函数调用运算符
	（1）如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象。
	（2）函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或
		类型上有所区别。
	（3）如果类定义了调用运算符，则该类的对象称作函数对象（function object）。
	（4）当我们编写一个lambda后，编译器将该表达式翻译成一个未命名类的未命名对象。在lambda表达式产生的类
		中含有一个重载的函数调用运算符。
	（5）lambda表达式产生的类不含默认构造函数、赋值运算符及默认析构函数；它是否含有默认的拷贝/移动构造函数
		则通常要视捕获的数据成员类型而定。
9. 标准库定义的函数对象
	标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用
	运算符。
	example:
	  plus<int> intAdd;
	  int sum = intAdd(10, 20);
	functional头文件中定义的函数对象类型
	--------------------------------------------------------------------------------------------------
												标准库函数对象
	--------------------------------------------------------------------------------------------------
		算术								关系							逻辑
		plus<Type>							equal_to<Type>					logical_and<Type>
		minus<Type>							not_equal_to<Type>				logical_or<Type>
		multiplies<Type>					greater<Type>					logical_not<Type>
		divides<Type>						greater_equal<Type>
		modulus<Type>						less<Type>
		negate<Type>						less_equal<Type>
	--------------------------------------------------------------------------------------------------
	需要注意的是，标准库规定其函数对象对于指针同样适用。
	vector<string *> nameTable;
	// 错误：nameTable中的指针彼此之间没有关系，所以<将产生未定义的行为
	sort(nameTable.begin(), nameTable.end(), [](string *a, string *b){return a < b; });
	// 正确：标准库规定指针的less是定义良好的
	sort(nameTable.begin(), nameTable.end(), less<string*>());
10. C++语言中有几种可调用的对象：函数、函数指针、lambda表达式、bind创建的对象以及重载了函数调用运算符的类。
11. 标准库function类型(定义在functional头文件中)
	-------------------------------------------------------------------------------------------------
											function的操作
	-------------------------------------------------------------------------------------------------
	function<T> f;			f是一个用来存储可调用对象的空function，这些可调用对象的调用形式应该与函数
							类型T相同（即T是retType(args)）
	function<T> f(nullptr); 显式地构造一个空function
	function<T> f(obj);		在f中存储可调用对象obj的副本
	f						将f作为条件：当f含有一个可调用对象时为真；否则为假
	f(args)					调用f中的对象，参数是args
	定义为function<T>的成员的类型
	result_type				该function类型的可调用对象返回的类型
	argument_type			当T有一个或两个实参时定义的类型。如果T只有一个实参，
	first_argument_type		则argument_type是该类型的同义词；如果T有两个实参，
	second_argument_type	则first_argument_type和second_argument_type分别代表两个实参的类型
	-------------------------------------------------------------------------------------------------
	example:
	map<string, function<int(int, int)>> binops = {
		{"+", add},										// 函数指针
		{"-", std::minus<int>()},						// 标准库函数对象
		{"/", divide()},								// 用户定义的函数对象
		{"*", [](int i, int j) { return i * j;}},		// 未命名的lambda
		{"%", mod}										// 命名了的lambda对象
	};
12. 我们不能（直接）将重载函数的名字存入function类型的对象中。解决二义性问题的一条途径是存储函数指针而非
	函数的名字，同时我们也能使用lambda来消除二义性。
13. 转换构造函数和类型转换运算符共同定义了类类型转换(class-type conversions)，这样的转换有时也被称作用户
    定义的类型转换(user-defined conversions)。
14. 类型转换运算符(conversion operator)是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。类型
	转换函数的一般形式如下所示：
	operator type() const;
	其中type表示某种类型。类型转换运算符可以面向任意leixing(除了void之外)进行定义，只要改类型能作为函数的
	返回类型。
	一个类型转换函数必须是类的成员函数；它不能声明返回类型，形参列表也必须为空。类型转换函数通常应该是const;
15. C++11新标准引入了显式的类型转换运算符(explicit conversion operator):
	class SmallInt{
	public:
		// 编译器不会自动执行这一类型转换
		explicit operator int() const{ return val;}
		// 其他成员与之前的版本一致
	};
	和显式地构造函数一样，编译器（通常）也不会将一个显式地类型转换运算符用于隐式类型转换。
	档类型转换运算符是显式的时，我们也能执行类型转换，不过必须通过显式地强制类型转换才可以。
	该规定存在一个例外，即如果表达式被用作条件，则编译器将会显式的类型转换自动应用于它。
16. 避免有二义性的类型转换：
	1）通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及两个以上转换源或转换目标是算术类型的转换。
17. 表达式中运算符的候选集既应该包括成员函数，也应该包括非成员函数。
*/
