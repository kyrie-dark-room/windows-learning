#pragma once
/*
1. 当定义一个类时，我们显式地或隐式地指定在此类型的对象拷贝、移动、赋值和销毁时做什么。一个类通过定义
   五种特殊的成员函数来控制这些操作，包括：
   (1) 拷贝构造函数(copy constructor)
   (2) 拷贝赋值运算符(copy-assignment operator)
   (3) 移动构造函数(move constructor)
   (4) 移动赋值运算符(move-assignment operator)
   (5) 析构函数(destructor)
   如果一个类没有定义所有这些拷贝控制成员，编译器会自动为它定义缺失的操作。因此，很多类会忽略这些拷贝
   控制操作。但是，对一些类来说，依赖这些操作的默认定义会导致灾难。通常，实现拷贝控制操作最困难的地方
   是首先认识到什么时候需要定义这些操作。
2. 拷贝构造函数
   如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数时拷贝构造函数。
   class Foo{
   public:
		Foo();				// 默认构造函数
		Foo(const Foo&);	// 拷贝构造函数
		// ...
   }
3. 现在，我们可以完全理解直接初始化和拷贝初始化之间的差异了
	string dots(10, '.');			// 直接初始化
	string s(dots);					// 直接初始化
	string s2 = dots;						// 拷贝初始化
	string null_book = "9-999-99999-9";		// 拷贝初始化
	string nines = string(100, '9');		// 拷贝初始化
   当时用直接初始化时，我们实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。
   当我们使用拷贝初始化时，我们要求编译器将右侧运算符对象拷贝到正在创建的对象中，如果需要的话还要进行类型
   转换。
4. 拷贝初始化不仅在我们用=定义变量时会发生，在下列情况下也会发生
	・将一个对象作为实参传递给一个非引用类型的形参
	・从一个返回类型为非引用类型的函数返回一个对象
	・用花括号列表初始化一个数组中的元素或一个聚合类中的成员。
   某些类类型还会对它们所分配的对象使用拷贝初始化。例如，当我们初始化标准库容器或是调用其insert或push
   成员时，容器会对其元素进行拷贝初始化。与之相对，用emplace成员创建的元素都进行直接初始化。
5. 编译器可以绕过拷贝构造函数
   在拷贝初始化过程中，编译器可以（但不是必须）跳过拷贝/移动构造函数，直接创建对象。即，编译器被允许
   将下面的代码
		string null_book = "9-999-99999-9";		// 拷贝初始化
   改写为
		string null_book("9-999-99999-9");
   但是，及时编译器略过了拷贝/移动构造函数，但在这个程序点上，拷贝/移动构造函数必须是存在且可访问的。
6. 重载运算符本质上是函数，其名字由operator关键字后接表示要定义的运算符的符号组成。因此，赋值运算符
   就是一个名为operator=的函数。
7. 拷贝赋值运算符接受一个与其所在类相同类型的参数：
	class Foo {
		public:
			Foo& operator=(const Foo&);	// 赋值运算符
			// ...
	};
   为了与内置类型的赋值保持一致，赋值运算符通常返回一个指向其左侧运算对象的引用。另外值得注意的是，
   标准库通常要求保存在容器中的类型要具有赋值运算符，且其返回值是左侧运算对象的引用。
8. 一个疑问？
   Sales_data&
   Sales_data::operator=(const Sales_data& rhs)
   {
		bookNo = rhs.bookNo;			// 调用string::operator=
		units_sold = rhs.units_sold;	// 使用内置的int赋值
		revenue = rhs.revenue;			// 使用内置的double赋值
		return *this;					// 返回一个此对象的引用
   }
   为什么拷贝构造函数或拷贝赋值运算符的参数可以直接去访问它自己的私有成员？
   解答：
		之所以会有上面的那个疑问，无疑的就是进入了一个认识误区――对象是不可以直接访问私有成员的。
		(1) 我们先来看，私有，公有，受保护的，是针对什么东西来谈的：不是针对对象来说的，是针对于类来
		说的。是用来限定类外的东西访问类内的东西是有限制的。从来不是对对象而言的。封装是编译期的
		概念，是针对类型而非对象的，在类的成员函数中可以访问同类型实例对象的私有成员变量．
		(2) 对象能否访问到私有成员与其定义的位置有关：在类内定义，可以访问，在类外定义，不能访问。
9. 什么时候会调用析构函数
	无论何时一个对象被销毁，就会自动调用其析构函数：
	・变量在离开其作用域时被销毁。
	・当一个对象被销毁时，其成员被销毁。
	・容器（无论是标准库容器还是数组）被销毁时，其元素被销毁。
	・对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁。
	・对于临时对象，当创建它的完整表达式结束时被销毁。
10. 认识到析构函数体自身并不直接销毁成员是非常重要的。成员是在析构函数体之后隐含的析构阶段中被销毁的。
    在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的。
11. 三/五法则
	(1) 需要析构函数的类也需要拷贝和赋值操作：当我们决定一个类是否要定义它自己版本的拷贝控制成员时，
	一个基本原则是首先确定这个类是否需要一个析构函数。通常，对析构函数的需求要比对拷贝构造函数或赋值
	运算符的需求更加明显。如果这个类需要一个析构函数，我们几乎可以肯定它也需要要给拷贝构造函数和一个
	拷贝赋值运算符。
	(2) 需要拷贝操作的类也需要赋值操作，反之亦然：如果一个类需要拷贝构造函数，几乎可以肯定它也需要一个
	拷贝赋值运算符。反之亦然--如果一个类需要一个拷贝赋值运算符，几乎可以肯定它也需要一个拷贝构造函数。
	然而，无论是需要拷贝构造函数还是需要拷贝赋值运算符都不必然意味着也需要析构函数。
12. 我们可以通过将拷贝控制成员定义为=default来显式地要求编译器生成合成的版本。
	class Sales_data{
	public:
		// 拷贝控制成员；使用default
		Sales_data() = default;
		Sales_data(const Sales_data&) = default;
		Sales_data& operator=(const Sales_data &);
		~Sales_data() = default;
		// 其他成员的定义，如前
	};
	Sales_data& Sales_data::operator=(const Sales_data&) = default;
13. 当我们在类内用=default修饰成员的声明时，合成的函数将隐式地声明为内联的（就像任何其他类内声明的成员
	函数一样）。如果我们不希望合成的成员是内联函数，应该只对成员的类外定义使用=default，就像对拷贝赋值
	运算符所做的那样。
14. 我们只能对具有合成版本的成员函数使用=default（即，默认构造函数或拷贝控制成员）。
15. 在新标准下，我们可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数（deleted function）来阻止
	拷贝。删除的函数时这样一种函数：我们虽然声明了它们，但不能以任何方式使用它们。在函数的参数列表后面
	加上=delete来指出我们希望将它定义为删除的。
	struct NoCopy{
		NoCopy() = default;   // 使用合成的默认构造函数
		NoCopy(const NoCopy&)=delete;	// 阻止拷贝
		NoCopy &operator=(const NoCopy&) = delete;	// 阻止赋值
		~NoCopy() = default;	// 使用合成的析构函数
		// 其他成员
	};
	与=default的另一个不同之处是，我们可以对任何函数指定=delete，虽然删除函数的主要用途是禁止拷贝控制
	成员，但当我们希望引导函数匹配过程时，删除函数有时也是有用的。
16. 值得注意的是，我们不能删除析构函数。如果析构函数被删除，就无法销毁此类型的对象了。对于一个删除了
	析构函数的类型，编译器将不允许定义该类型的变量或创建该类的临时对象。而且，如果一个类有某个成员的
	类型删除了析构函数，我们也不能定义该类的变量或临时对象。
	对于析构函数已删除的类型，不能定义该类型的变量或释放指向该类型动态分配对象的指针。
17. 对某些类来说，编译器将这些合成的成员定义为删除的函数：
	1) 如果类的某个成员的析构函数是删除的或不可访问的（例如，是private的），则类的合成析构函数被定义为
	  删除的。
	2) 如果类的某个成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的。如果类
	  的某个成员的析构函数是删除的或不可访问的，则类合成的拷贝构造函数也被定义为删除的。
	3) 如果类的某个成员的拷贝赋值运算符是删除的或不可访问的，或是类有一个const的或引用成员，则类的合成
	  拷贝赋值运算符被定义为删除的。
	4) 如果类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，它没有类内初始化器，或是类
	  有一个const成员，它没有类内初始化器且其类型未显示定义默认构造函数，则该类的默认构造函数被定义为删除
	  的。
    本质上，这些规则的含义是：如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义
	为删除的。
18. 在新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为private的来阻止拷贝。但是友元和成员
	函数仍旧可以拷贝对象。为了阻止友元和成员函数进行拷贝，我们将这些拷贝控制成员声明为private的，但不
	定义他们。
	声明但不定义一个成员函数时合法的，试图访问一个未定义的成员将导致一个链接时错误。通过声明（但不定义）
	private的拷贝构造函数，我们可以预先阻止任何拷贝该类型对象的企图：试图拷贝对象的用户代码将在编译阶段
	被标记为错误；成员函数或友元函数中的拷贝操作将会导致链接时错误。
	希望阻止拷贝的类应该使用=delete来定义它们自己的拷贝构造函数和拷贝赋值运算符，而不应该将它们声明为
	private的。
19. 当你编写赋值运算符时，有两点需要记住：
	1) 如果将一个对象赋予它自身，赋值运算符必须能正确工作。
	2) 大多数赋值运算符组合了析构函数和拷贝构造函数的工作。
	当你编写一个赋值运算符时，一个好的模式是先将右侧运算符对象拷贝到一个局部临时对象中。当拷贝完成后，
	销毁左侧运算对象的现有成员就是安全的了。一旦左侧运算对象的资源被销毁，就只剩下将数据从临时对象拷贝
	到左侧运算对象的成员中了。
	HasPtr& HasPtr::operator=(const HasPtr &rhs)
	{
		auto newp = new string(*rhs.ps); // 拷贝底层string
		delete ps;	// 释放旧内存
		ps = newp;	// 从右侧运算对象拷贝数据到本对象
		i = rhs.i;
		return *this; // 返回本对象
	}
20. 引用计数的工作方式如下：
	・除了初始化对象外，每个构造函数（拷贝构造函数除外）还要创建一个引用计数，用来记录有多少对象与正在
	  创建的对象共享状态。当我们创建一个对象时，只有一个对象共享状态，因此将计数器初始化为1
	・拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器，
	  指定给定对象的状态又被一个新用户所共享。
	・析构函数递减计数器，指出共享状态的用户少了一个。如果计数器变为0，则析构函数释放状态。
	・拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，意味着
	  它的共享状态没有用户了，拷贝赋值运算符就必须销毁状态。
21. 唯一的难题是确定在哪里存放引用计数。计数器不能直接作为HasPtr对象的成员。下面的例子说明了原因：
	HasPtr p1("Hiya!");
	HasPtr p2(p1);  // p1和p2指向相同的string
	HasPtr p3(p1);	// p1、p2和P3都指向相同的string
	如果引用计数保存在每个对象中，当创建p3时我们应该如何正确更新它呢？可以递增p1中的计数器并将其拷贝
	到p3中，但如何更新p2中的计数器呢？
22. 解决21问题的一种方法是将计数器保存在动态内存中。当创建一个对象时，我们也分配一个新的计数器。当拷贝
	或赋值对象时，我们拷贝指向计数器的指针。使用这种方法，副本和原对象都会指向相同的计数器。
	定义一个使用引用计数的类
	class HasPtr{
		public:
			// 构造函数分配新的string和新的计数器，将计数器置为1
			HasPtr(const std::string &s = std::string()):
				ps(new std::string(s)), i(0), use(new std::size_t(1)){}
			// 拷贝构造函数拷贝所有三个数据成员，并递增计数器
			HasPtr(const HasPtr &p):
				ps(p.ps), i(p.i), use(p.use){++*use;}
			HasPtr& operator=(const HasPtr&);
			~HasPtr();
		private:
			std::string *ps;
			int i;
			std::size_t *use;	// 用来记录有多少个对象共享*ps的成员
	};

	HasPtr::~HasPtr()
	{
		if (--*use == 0){	// 如果引用计数变为0
			delete ps;		// 释放string内存
			delete use;		// 释放计数器内存
		}
	}

	HasPtr& HasPtr::operator=(const HasPtr &rhs)
	{
		++*rhs.use;				// 递增右侧运算符对象的引用计数
		if (--*use == 0){		// 然后递减本对象的引用计数
			delete ps;			// 如果没有其他用户
			delete use;			// 释放本对象分配的成员	
		}
		ps = rhs.ps;			// 将数据从rhs拷贝到本对象
		i = rhs.i;
		use = rhs.use;
		return *this;			// 返回本对象
	}
23. 与拷贝控制成员不同，swap并不是必要的。但是，对于分配了资源的类，定义swap可能是一种很重要的优化手段。
24. 如果一个类的成员有自己类型特定的swap函数，调用std::swap就是错误的了。
25. 定义swap的类通常用swap来定义它们的赋值运算符。这些运算符使用了一种名为拷贝并交换（copy and swap）
	的技术。这种技术将左侧运算对象与右侧运算对象的一个副本进行交换：
	// 注意rhs是按值传递的，意味着HasPtr的拷贝构造函数
	// 将右侧运算对象中的string拷贝到rhs
	HasPtr& HasPtr::operator=(HasPtr rhs)
	{
		// 交换左侧运算对象和局部变量rhs的内容
		swap(*this, rhs);	// rhs现在指向本对象曾经使用的内存
		return *this;		// rhs被销毁，从而delete了rhs中的指针
	}
	在这个版本的赋值运算符中，参数并不是一个引用。
	这个技术的有趣之处就是它自动处理了自赋值情况且天然就是异常安全的。
26. 新标准的一个最主要的特性是可以移动而非拷贝对象的能力。使用移动而不是拷贝的原因：
	(1) 某些情况下，对象拷贝后就立即被销毁了。再重新分配内存的过程中，从旧内存将元素拷贝到新内存是不
	必要的，更好的方式是移动元素。
	(2) IO类或unique_ptr这样的类。这些类都包含不能被共享的资源（如指针或IO缓冲）。因此，这些类型的对象
	不能拷贝但可以移动。
27. 在旧C++标准中，没有直接的方法移动对象。因此，即使不必拷贝对象的情况下，我们也不得不拷贝。如果对象
	较大，或者是对象本身要求分配内存空间(如string)，进行不必要的拷贝代价非常高。类似的，在旧版本的标
	准库中，容器中所保存的类必须是可拷贝的。但在新标准中，我们可以用容器保存不可拷贝的类型，只要它们能
	被移动即可。
28. 标准库容器、string和shared_ptr类既支持移动也支持拷贝。IO类和unique_ptr类可以移动但不能拷贝。
29. 右值引用：所谓右值引用就是必须绑定到右值的引用。我们通过&&而不是&来获得右值引用。
30. 右值引用有一个重要的性质--只能绑定到一个将要销毁的对象。因此，我们可以自由地将一个右值引用的资源
	“移动”到另一个对象中。
31. 常规引用（左值引用(lvalue reference)）,我们不能将其绑定到要求转换的表达式、字面常量或是返回右值的
    表达式。右值引用有着完全相反的绑定特性：我们可以将一个右值引用绑定到这类表达式上，但不能将一个右值
	引用直接绑定到一个左值上。
32. 返回左值引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都是返回左值的表达式的例子。我们可以
	将一个左值引用绑定到这类表达式的结果上。
33. 返回非引用类型的函数，连同算术、关系、位以及后置递增/递减运算符，都生成右值。我们不能将一个左值引用
	绑定到这类表达式上，但我们可以将一个const的左值引用或者一个右值引用绑定到这类表达式上。
34. 左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。由于右值引用只能
	绑定到临时对象，我们得知
	・所引用的对象将要被销毁
	・该对象没有其它用户
	这两个特性意味着：使用右值引用的代码可以自由地接管所引用的对象的资源。
	右值引用指向将要被销毁的对象。因此，我们可以从绑定到右值引用的对象“窃取”状态。
35. 变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行。
36. 虽然不能将一个右值引用直接绑定到一个左值上，但我们可以显示地将一个左值转换为对应的右值引用类型。
	我们还可以通过调用一个名为move的新标准库函数来获得绑定到左值上的右值引用，此函数定义在头文件utility中。
		int &&rr1 = 42;				// 正确：字面常量是右值
		int &&rr2 = rr1;			// 错误：表达式rr1是左值！
		int &&rr3 = std::move(rr1);	// ok
	move调用告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。我们必须认识到，调用move就意味着
	承诺：除了对rr1赋值或销毁它外，我们将不再使用它。
	我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值。
	使用move的代码应该使用std::move而不是move。这样做可以避免潜在的名字冲突。
37. 类似拷贝构造函数，移动构造函数的第一个参数是该类类型的一个引用。不同于拷贝构造函数的是，这个引用
	参数在移动构造函数中是一个右值引用。与拷贝构造函数一样，任何额外的参数都必须有默认实参。
38. 除了完成资源移动，移动构造函数还必须确保移后源对象处于这样一个状态--销毁它是无害的。特别是，一旦
	资源完成移动，源对象必须不再指向被移动的资源--这些资源的所有权已经归属新创建的对象。
	example:
	StrVec::StrVec(StrVec &&s) noexcept  // 移动操作不应抛出任何异常
		// 成员初始化器接管s中的资源
		: elements(s.elements), first_free(s.first_free), cap(s.cap)
	{
		// 令s进入这样的状态--对其运行析构函数是安全的
		s.elements = s.first_free = s.cap = nullptr;
	}
39. 由于移动操作“窃取”资源，它通常不分配任何资源。因此，移动操作通常不会抛出任何异常。当编写一个不抛出
	异常的移动操作时，我们应该将此事通知标准库。我们将看到，除非标准库知道我们的移动构造函数不会抛出异常，
	否则它会认为移动我们的类对象时可能会抛出异常，并且为了处理这种可能性而做一些额外的工作。
40. 一种通知标准库的方法是在我们的构造函数中指明noexcept。noexcept是新标准引入的，目前重要的是要知道，
	noexcept使我们承诺一个函数不抛出异常的一种方法。我们在一个函数的参数列表后指定noexcept。在一个构造
	函数中，noexcept出现在参数列表和初始化列表开始的冒号之间：
	class StrVec {
	public:
		StrVec(StrVec&&) noexcept;	// 移动构造函数
		// 其他成员的定义，如前
	};
	StrVec::StrVec(StrVec &&s) noexcept:  // 成员初始化器
	{ //构造函数 }
	我们必须在类头文件的声明中和定义中（如果定义在类外的话）都指定noexcept。
41. 搞清楚为什么需要noexcept能帮助我们深入理解标准库是如何与我们自定义的类型交互的。我们需要指出一个
	移动操作不抛出异常，这是因为两个相互关联的事实：首先，虽然移动操作通常不抛出异常，但抛出异常也是
	允许的；其次，标准库容器能对异常发生时其自身的行为提供保证。例如，vector保证，如果我们调用push_back
	时发生异常，vector自身不会发生改变。
	为了满足自身不会改变的要求，除非vector知道元素类型的移动构造函数不会抛出异常，否则在重新分配内存的
	过程中，它就必须使用拷贝构造函数而不是移动构造函数。如果希望vector重新分配内存这类情况下对我们自定义
	类型的对象进行移动而不是拷贝，就必须显式地告诉标准库我们的移动构造函数可以安全使用。
42. 移动赋值运算符必须正确处理自赋值：
	StrVec &StrVec::operator=(StrVec &&rhs) noexcept
	{
		// 直接检测自赋值
		if (this != &rhs){
			free();						// 释放已有元素
			elements = rhs.elements;	// 从rhs接管资源
			first_free = rhs.first_free;
			cap = rhs.cap;
			// 将rhs置于可析构状态
			rhs.elements = rhs.first_free = rhs.cap = nullptr;
		}
		return *this;
	}
	我们费心地去检查自赋值情况看起来有些奇怪。毕竟，移动赋值运算符需要右侧运算对象的一个右值。我们进行
	检查的原因是move调用的返回结果。
43. 除了将移后源对象置为析构安全的状态之外，移动操作还必须保证对象仍然是有效的。一般来说，对象有效就是
	指可以安全地为其赋予新值或者可以安全地使用而不依赖其当前值。另一方面，移动操作对移后源对象中留下的
	值没有任何要求。因此，我们的程序不应该依赖于移后源对象中的数据。
	在移动操作之后，移动源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设。
44. 与拷贝操作不同，编译器根本不会为某些类合成移动操作。特别是，如果一个类定义了自己的拷贝构造函数、
	拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符了。只有当一个类没有
	定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动
	构造函数或移动赋值运算符。
45. 与拷贝操作不同，移动操作永远不会隐式定义为删除的函数。但是，如果我们显式地要求编译器生成=default
	的移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数。出了一个重要例外，什么
	时候将合成的移动操作定义为删除的函数遵循与定义删除的合成拷贝操作类似的原则：
	・与拷贝构造函数不同，移动构造函数被定义为删除的函数的条件是：有类成员定义了自己的拷贝构造函数且
	  未定义移动构造函数，或者是有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数。移动
	  赋值运算符的情况类似。
	・如果有类成员的移动构造函数或移动赋值运算符被定义为删除的或是不可访问的，则类的移动构造函数或移动
	  赋值运算符被定义为删除的。
	・类似拷贝构造函数，如果类的析构函数被定义为删除的或不可访问的，则类的移动构造函数被定义为删除的。
	・类似拷贝赋值运算符，如果有类成员是const的或是引用，则类的移动赋值运算符被定义为删除的。
46. 移动操作和合成的拷贝控制成员间还有最后一个相互作用关系：一个类是否定义了自己的移动操作对拷贝操作
	如何合成有影响。如果类定义了一个移动构造函数和/或一个移动赋值运算符，则该类的合成拷贝构造函数和
	拷贝赋值运算符会被定义为删除的。
47. 如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数。
48. 如果一个类没有移动构造函数，函数匹配规则保证该类型的对象会被拷贝，即使我们试图通过调用move来移动
	它们时也是如此。
49. 示例：如果我们为此类添加一个移动构造函数，它实际上也会获得一个移动赋值运算符：
	class HasPtr {
	public:
		// 添加的移动构造函数
		HasPtr(HasPtr &&p) noexcept: ps(p.ps), i(p.i) {p.ps = 0;}
		// 赋值运算符既是移动赋值运算符，也是拷贝赋值运算符
		HasPtr& operator=(HasPtr rhs)
				{ swap(*this, rhs); return *this; }
		// 其他成员的定义
	};
	现在让我们观察赋值运算符。此运算符有一个非引用参数，这意味着此参数要进行拷贝初始化。依赖于实参的
	类型，拷贝初始化要么使用拷贝构造函数，要么使用移动构造函数--左值被拷贝，右值被移动。因此，单一的
	赋值运算符就实现了拷贝赋值运算符和移动赋值运算符两种功能。
50. 更新三/五法则
	所有五个拷贝控制成员应该看作一个整体：一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有
	五个操作。
51. 新标准库中定义了一种移动迭代器(move iterator)适配器。一个移动迭代器通过改变给定迭代器的解引用运算符
	符的行为来适配此迭代器。一般来说，一个迭代器的解引用运算符返回一个指向元素的左值。与其他迭代器不同，
	移动迭代器的解引用运算符生成一个右值引用。
52. 我们通过调用标准库的make_move_iterator函数将一个普通迭代器转换为一个移动迭代器。此函数接受一个迭代器
	参数，返回一个移动迭代器。
	原迭代器的所有其他操作在移动迭代器中都照常工作。由于移动迭代器支持正常的迭代器操作，我们可以将一对
	移动迭代器传递给算法。
	example:
	void StrVec::reallocate()
	{
		// 分配大小两倍于当前规模的内存空间
		auto newcapacity = size() ? 2 * size() : 1;
		auto first = alloc.allocate(newcapacity);
		// 移动元素
		auto last = uninitialized_copy(make_move_iterator(begin()),
										make_move_iterator(end()),
										first);
		free();	// 释放旧空间
		elements = first;	// 更新指针
		first_free = last;
		cap = elements + newcapacity;
	}
53. 值得注意的是，标准库不保证哪些算法适用移动迭代器，哪些不适用。由于移动一个对象可能销毁掉原对象，因此
	你只有在确信算法在为一个元素赋值或将其传递给一个用户定义的函数后不再访问它时，才能将移动迭代器传递给算法。
54. 通过在类代码中小心地使用move，可以大幅度提升性能。而如果随意在普通用户代码（与类实现代码相对）中使用
	移动操作，很可能导致莫名其妙的、难以查找的错误，而难以提升应用程序性能。
	在移动构造函数和移动赋值运算符这些类实现代码之外的地方，只有当你确信需要进行移动操作且移动操作是
	安全的，才可以使用std::move。
55. 除了构造函数和赋值运算符之外，如果一个成员函数同时提供拷贝和移动版本，它也能从中受益。这种允许移动
	的成员函数通常使用与拷贝/移动构造函数和赋值运算符相同的参数模式--一个版本接受一个指向const的左值
	引用，第二个版本接受一个指向非const的右值引用。
	example:
	class StrVec{
		void push_back(const std::string&);	// 拷贝元素
		void push_back(std::string&&);		// 移动元素
	}
56. 有时，右值的引用方式可能令人惊讶：
		s1 + s2 = "wow!";
	此处我们对两个string的连接结果--一个右值，进行了赋值。
	在旧标准中，我们没有办法阻止这种使用方式。为了维持向后兼容性，新标准库类仍然允许向右值赋值。但是，
	我们可能希望在自己的类中阻止这种用法。在此情况下，我们希望强制左侧运算符(即，this指向的对象)是一个左值。
57. 我们指出this的左值/右值属性的方式与定义const成员函数相同，即，在参数列表后放置一个引用限定符(reference qualifier):
	example:
	class Foo{
	public:
		Foo &operator=(const Foo&) &;	// 只能向可修改的左值赋值
		// Foo的其他参数
	};
	Foo &Foo::operator=(const Foo &rhs) &
	{
		// 执行将rhs赋予本对象所需的工作
		return *this;
	}
	引用限定符可以是&或&&，分别指出this可以指向一个左值或右值。类似const限定符，引用限定符只能用于(非static)成员函数，
	且必须同时出现在函数的声明和定义中。
58. 一个函数可以同时用const和引用限定。在此情况下，引用限定符必须跟随在const限定符之后。
59. 就像一个成员函数可以根据是否有const来区分其重载版本一样，引用限定符也可以区分重载版本。而且，我们
	可以综合引用限定符和const来区分一个成员函数的重载版本。
60. 当我们定义const成员函数时，可以定义两个版本，唯一的区别是一个版本有const限定而另一个没有。引用限定
	的函数则不一样。如果我们定义两个或两个以上具有相同名字和相同参数列表的成员函数，就必须对所有函数
	都加上引用限定符，或者所有都不加。
*/