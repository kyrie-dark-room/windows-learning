#pragma once
/*
1. 为了更容易（同时也更安全）地使用动态内存，新的标准库提供了两种智能指针（smart pointer）类型来管理
   动态对象。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。新标准库提供的两种
   智能指针的区别在于管理底层指针的方式：
   （1）shared_ptr允许多个指针指向同一个对象；
   （2）unique_ptr则“独占”所指向的对象。
   标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。
   这三种类型都定义在memory头文件中。
2. -------------------------------------------------------------------------------------------------
									shared_ptr和unique_ptr都支持的操作
   -------------------------------------------------------------------------------------------------
   shared_ptr<T> sp		空智能指针，可以指向类型为T的对象
   unique_ptr<T> up
   p					将p用作一个条件判断，若p指向一个对象，则为true
   *p					解引用p，获得它指向的对象
   p->mem				等价于（*p）.mem
   p.get()				返回p中保存的指针。要小心使用，若智能指针释放了其对象，返回的指针所指向
						的对象也就消失了
   swap(p, q)			交换p和q中的指针
   p.swap(q)			
   -------------------------------------------------------------------------------------------------
3. -------------------------------------------------------------------------------------------------
									shared_ptr独有的操作
   -------------------------------------------------------------------------------------------------
   make_shared<T>(args) 返回一个shared_ptr，指向一个动态分配的类型为T的对象。使用args初始化此对象
   shared_ptr<T>p(q)    p是shared_ptr q的拷贝；此操作会递增q中的计数器。q中的指针必须能转换为T*
   p = q				p和q都是shared_ptr，所保存的指针必须能相互转换。此操作会递增p的引用计数，
						递增q的引用计数；若p的引用计数变为0，则将其管理的原内存释放
   p.unique()			若p.use_count()为1，返回true；否则返回false
   p.use_count()		返回与p共享对象的智能指针数量；可能很慢，主要用于调试
   -------------------------------------------------------------------------------------------------
4. 程序使用动态内存处于以下三种原因之一：
   （1）程序不知道自己需要使用多少对象
   （2）程序不知道所需对象的准确类型
   （3）程序需要在多个对象间共享数据
5. 在自由空间分配的内存是无名的，因此new无法为其分配的对象命名，而是返回一个指向该对象的指针。
6. 默认情况下，动态分配的对象是默认初始化的，这意味着内置类型或组合类型的对象的值将是未定义的，而
   类类型对象将用默认构造函数进行初始化。类似的，对于类中那些依赖于编译器合成的默认构造函数的内置类型
   成员，如果我们未在类内被初始化，那么它们的值也是未定义的。
   出于与变量初始化相同的原因，对动态分配的对象进行初始化通常是个好主意。
7. 默认情况下，如果new不能分配所要求的内存空间，它会抛出一个类型为bad_alloc的异常。我们可以改变使用
   new的方式来阻止它抛出异常：
   int *p1 = new int;  // 如果分配失败，new抛出std::bad_alloc
   int *p2 = new (nothrow) int;  // 如果分配失败，new返回一个空指针
   我们称这种形式的new为定位new(placement new)
8. 接受指针参数的智能指针构造函数是explicit的。因此，我们不能将一个内置指针隐式转换为一个智能指针，
   必须使用直接初始化形式来初始化一个智能指针。
9. -------------------------------------------------------------------------------------------------
									定义和改变shared_ptr的其他方法
   -------------------------------------------------------------------------------------------------
   shared_ptr<T> p(q)		p管理内置指针q所指向的对象；q必须指向new分配的内存，且能够转换为T*类型
   shared_ptr<T> p(u)		p从unique_ptr u那里接管了对象的所有权；将u置为空
   shared_ptr<T> p(q, d)	p接管了内置指针q所指向的对象的所有权。q必须能转换为T*类型。p将使用可调用
							对象d来代替delete。
   shared_ptr<T> p(p2, d)	p是shared_ptr p2的拷贝，唯一的区别是p将用可调用对象d来代替delete
   p.reset()				若p是唯一指向其对象的shared_ptr，reset会释放此对象。若传递了可选的参数
   p.reset(q)				内置指针q，会令p指向q,否则会将p置为空。若还传递了参数d，将会调用d而不是
   p.reset(q, d)			delete来释放q
   -------------------------------------------------------------------------------------------------
10. 智能指针类型定义了一个名为get的函数，它返回一个内置指针，指向智能指针管理的对象。此函数是为了一种
	情况而设计的：我们需要向不能使用智能指针的代码传递一个内置指针。使用get返回的指针的代码不能delete
	此指针。
11. 默认情况下，shared_ptr假定它们指向的是动态内存。因此，当一个shared_ptr被销毁时，它默认地对它管理
    的指针进行delete操作。为了用shared_ptr来管理一个connection,我们必须首先定义一个函数来代替delete。
	这个删除器(deleter)函数必须能够完成对shared_ptr中保存的指针进行释放的操作。在本例中，我们的删除
	器必须接受单个类型为connection*的参数：
		void end_connection(connection *p) { disconnect(*p);}
	当我们创建一个shared_ptr时，可以传递一个（可选的）指向删除器函数的参数：
		void f(destination &d)
		{
			connection c = connect(&d);
			shared_ptr<connection> p(&c, end_connection);
			// 使用连接
			// 当f退出时（即使是由于异常而退出），connection会被正确关闭
		}
12. 注意：智能指针陷阱
	智能指针可以提供对动态分配的内存安全而又方便的管理，但这建立在正确使用的前提下。为了正确使用智能
	指针，我们必须坚持一些基本规范：
	・不使用相同的内置指针初始化（或reset）多个智能指针。
	・不delete get()返回的指针。
	・不使用get()初始化或reset另一个智能指针。
	・如果你使用get()返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效了。
	・如果你使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器。
13. 一个unique_ptr“拥有”它所指向的对象。与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定
	对象。当unique_ptr被销毁时，它所指向的对象也被销毁。
14. ------------------------------------------------------------------------------------------------
											unique_ptr操作
	------------------------------------------------------------------------------------------------
	unique_ptr<T> u1		空unique_ptr，可以指向类型为T的对象。u1会使用delete来释放它的指针；u2会
	unique_ptr<T, D> u2		使用一个类型为D的可调用对象来释放它的指针
	unique_ptr<T, D> u(d)	空unique_ptr，指向类型为T的对象，用类型为D的对象d代替delete
	u = nullptr				释放u指向的对象，将u置为空
	u.release()				u放弃对指针的控制权，返回指针，并将u置为空
	u.reset()				释放u指向的对象
	u.reset(q)				如果提供了内置指针q，令u指向这个对象；否则将u置位为空
	u.reset(nullptr)		
	------------------------------------------------------------------------------------------------
15. 不能拷贝unique_ptr的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的unique_ptr。最常用的例子是
	从函数返回一个unique_ptr:
	unique_ptr<int> clone(int p)
	{
		// 正确：从int*创建一个unique_ptr<int>
		return unique_ptr<int>(new int(p));
	}
16. 向后兼容：auto_ptr
	标准库的较早版本包含了一个名为auto_ptr的类，它具有unique_ptr的部分特性，但不是全部。特别是，我们
	不能在容器中保存auto_ptr，也不能从函数中返回auto_ptr。虽然auto_ptr仍是标准库的一部分，但编写程序
	时应该使用unique_ptr。
17. weak_ptr是一种不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的对象。将一个weak_ptr
	绑定到一个shared_ptr不会改变shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会
	被释放。即使有weak_ptr指向对象，对象也还是会被释放。因此，weak_ptr的名字抓住了这种智能指针“弱”
	共享对象的特点。
18. ------------------------------------------------------------------------------------------------
												weak_ptr
	------------------------------------------------------------------------------------------------
	weak_ptr<T> w			空weak_ptr可以指向类型为T的对象
	weak_ptr<T> w(sp)		与shared_ptr sp指向相同对象的weak_ptr。T必须能转换为sp指向的类型
	w = p					p可以是一个shared_ptr或一个weak_ptr。赋值后w与p共享对象
	w.reset()				将w置为空
	w.use_count()			与w共享对象的shared_ptr的数量
	w.expired()				若w.use_count()为0，则返回true，否则返回false
	w.lock()				如果expired为true，返回一个空shared_ptr；否则返回一个指向w的对象的shared_ptr
	------------------------------------------------------------------------------------------------
19. 虽然我们不能创建一个大小为0的静态数组对象，但当n等于0时，调用new[n]是合法的：
	char arr[0];				// 错误：不能定义长度为0的数组
	char *cp = new char[0];		// 正确：但cp不能解引用
	当我们用new分配一个大小为0的数组时，new返回一个合法的非空指针。此指针保证与new返回的其他任何指针都
	不相同。对于零长度的数组来说，此指针就像尾后指针一样，我们可以像使用尾后迭代器一样使用这个指针。
20. 为了释放动态数组，我们使用一种特殊形式的delete--在指针前加上一个空方括号对：
	delete p;	// p必须指向一个动态分配的对象或为空
	delete [] pa;	// pa必须指向一个动态分配的数组或为空
	第二条语句销毁pa指向的数组中的元素，并释放对应的内存。数组中的元素按逆序销毁。
21. 标准库提供了一个可以管理new分配的数组的unique_ptr版本。为了用一个unique_ptr管理动态数组，我们必须在
	对象类型后面跟一对空方括号：
	unique_ptr<int[]> up(new int[10]);
	up.release(); // 自动用delete[]销毁其指针
	当一个unique_ptr指向一个数组时，我们不能使用点和箭头成员运算符。毕竟unique_ptr指向的是一个数组而
	不是单个对象，因此这些运算符是无意义的。另一方面，当一个unique_ptr指向一个数组时，我们可以使用下
	标运算符来访问数组中的元素。
	------------------------------------------------------------------------------------------------
									指向数组的unique_ptr
	------------------------------------------------------------------------------------------------
	指向数组的unique_ptr不支持成员访问运算符（点和箭头运算符）。
	其他unique_ptr操作不变。
	unique_ptr<T[]> u		u可以指向一个动态分配的数组，数组元素类型为T
	unique_ptr<T[]> u(p)	u指向内置指针p所指向的动态分配的数组。p必须能转换为类型T*
	u[i]					返回u拥有的数组中位置i处的对象，u必须指向一个数组
	------------------------------------------------------------------------------------------------
22. 与unique_ptr不同，shared_ptr不直接支持管理动态数组。如果希望使用shared_ptr管理一个动态数组，必须
	提供自己定义的删除器：
	shared_ptr<int> sp(new int[10] [](int *){delete [] p;});
	sp.reset();	// 使用我们提供的lambda释放数组，它使用delete[]
	如果未提供删除器，这段代码将是未定义的。默认情况下，shared_ptr使用delete销毁它指向的对象。如果此
	对象是一个动态数组，对其使用delete所产生的问题与释放一个动态数组指针时忘记[]产生的问题一样。
	shared_ptr未定义下标运算符，而且智能指针类型不支持指针算术运算。因此，为了访问数组中的元素，必须
	用get获取一个内置指针，然后用它来访问数组元素。
	for (size_t i = 0; i != 10; ++i)
		*(sp.get() + i) = i;
23. allocator类
	（1）标准库allocator类定义在头文件memory中，它帮助我们将内存分配和对象构造分离开来。它提供一种类型
	感知的内存分配方法，它分配的内存是原始的、未构造的。
		类似vector，allocator是一个模板。为了定义一个allocator对象，我们必须指明这个allocator可以分配的
	对象类型。当一个allocator对象分配内存时，它会根据给定的对象类型来确定恰当的内存大小和对齐位置：
		allocator<string> alloc;
		auto const p = alloc.allocate(n);
	（2）标准库allocator类及其算法
		----------------------------------------------------------------------------------------------
		allocator<T> a		定义了一个名为a的allocator对象，它可以为类型为T的对象分配内存
		a.allocate(n)		分配一段原始的、未构造的内存，保存n个类型为T的对象
		a.deallocate(p, n)	释放从T*指针p中地址开始的内存，这块内存保存了n个类型为T的对象；p必须是一个
							先前由allocate返回的指针，且n必须是p创建时所需求的大小。在调用deallocate之前
							，用户必须对每个在这块内存中创建的对象调用destroy
		a.construct(p, args)	p必须是一个类型为T*的指针，指向一块原始内存；arg被传递给类型为T的构造函数
							，用来在p指向的内存中构造一个对象。
		a.destroy(p)		p为T*类型的指针，此算法对p指向的对象执行析构函数
		----------------------------------------------------------------------------------------------
	（3）拷贝和填充未初始化内存的算法
		标准库还为allocator类 定义了两个伴随算法，可以在未初始化内存中创建对象。它们都定义在头文件memory中
		-------------------------------------------------------------------------------------------------
												allocator算法
		-------------------------------------------------------------------------------------------------
		这些函数在给定目的位置创建元素，而不是由系统分配内存给它们
		uninitialized_copy(b,e,b2)		从迭代器b和e指出的输入范围中拷贝元素到迭代器b2指定的未构造的原始
										内存中。b2指向的内存必须足够大，能容纳输入序列中元素的拷贝
		uninitialized_copy_n(b,n,b2)	从迭代器b指向的元素开始，拷贝n个元素到b2开始的内存中
		uninitialized_fill(b,e,t)		在迭代器b和e指定的原始内存范围中创建对象，对象的均值为t的拷贝
		uninitialized_fill_n(b,n,t)		从迭代器b指向的内存地址开始创建n个对象。b必须指向足够大的未构造
										的原始内存，能够容纳给定数量的对象。
		-------------------------------------------------------------------------------------------------
*/