#pragma once
/*
1. 面向对象程序设计（object-oriented programming）的核心思想是数据抽象、继承和动态绑定。
   1）通过使用数据抽象，我们可以将类的接口与实现分离；
   2）使用继承，可以定义相似的类型并对其相似关系建模；
   3）使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。
2. 在C++语言中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的
   派生类各自定义适合自身的版本，此时基类就将这些函数声明成虚函数(virtual function)。
3. 在C++语言中，当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。
4. 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。
5. 任何构造函数之外的非静态函数都可以是虚函数。关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的
   函数定义。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。
6. 成员函数如果没被声明为虚函数，则其解析过程发生在编译时而非运行时。
7. 派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。和其他使用
   基类的代码一样，派生类能访问公有成员，而不能访问私有成员。不过在某些时候基类中还有这样一种成员，基类
   希望它的派生类有权访问该成员，同时禁止其他用户访问。我们用受保护的（protected）访问运算符说明这样的成员。
8. 派生类必须通过使用类派生列表（class derivation list）明确指出它是从哪个（哪些）基类继承而来的。类派生列表
   的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有以下三种访问说明符中的一个：
   pubilc、protected或者private。
9. 派生类经常（但不总是）覆盖它继承的虚函数。如果派生类没有覆盖其基类的某个虚函数，则该虚函数的行为类似于
   其他的普通函数，派生类会直接继承其在基类中的版本。
   派生类可以在它覆盖的函数前使用virtual关键字，但不是非得这么做。C++新标准允许派生类显式地注明它使用某个
   成员函数覆盖了它继承的虚函数。具体做法是在形参列表后面、或者在const成员函数的const关键字后面、或者在引用
   成员函数的引用限定符后面添加一个关键字override。
10.一个派生类对象包含多个组成部分：一个含有派生类自己定义的（非静态）成员的子对象，以及一个与该派生类
   继承的基类对应的子对象，如果有多个基类，那么这样的子对象也有多个。
11.C++标准并没有明确规定派生类的对象在内存中如何分布，但是我们可以认为包含如果所示两部分
                                     Bulk_quote对象
			从Quote继承而来的成员   -----------------
									  bookNo
									  price
									-----------------
			Bulk_quote自定义的成员	  min_qty
									  discount
									-----------------
			在一个对象中，继承自基类的部分和派生类自定义的部分不一定是连续存储的。
   因为在派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当作基类对象来使用，而且我们
   也能将基类的指针或引用绑定到派生类对象中的基类部分上。编译器会隐式地执行派生类到基类的转换。
12.在派生类对象中含有与其基类对应的组成部分，这一事实是继承的关键所在。
13.尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的
   代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分。即每个类控制它自己的成员初始化过程。
14.派生类构造函数同样是通过构造函数初始化列表来将实参传递给基类构造函数的。例如，接受四个参数的Bulk_quote
   构造函数如下所示：
       Bulk_quote(const std::string& book, double p,
	              std::size_t qty, double disc) :
				  Quote(book, p), min_qty(qty), discount(disc){}
   除非我们特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化。
   首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。
15.派生类可以访问基类的公有成员和受保护成员，派生类的作用域嵌套在基类的作用域之内。因此，对于派生类的一个成员
   来说，它使用派生类成员的方式与使用基类成员的方式没有什么不同。
16.如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，
   对于每个静态成员来说都只存在唯一的实例。
17.派生类的声明与其他类差别不大，声明中包含类名但是不包含它的派生列表。一条声明语句的目的是令程序知晓
   某个名字的存在以及该名字表示一个什么样的实体，如一个类、一个函数或一个变量等。
18.如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明。这一规定的原因显而易见：派生类中包含
   并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类当然要知道它们是什么。
19.C++11新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字final。
20.理解基类和派生类之间的类型转换是理解C++语言面向对象编程的关键所在。
21.可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义：当使用基类的引用（或指针）时，实际上
   我们并不清楚该引用（或指针）所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。
   和内置指针一样，智能指针类也支持派生类向基类的类型转换，这意味着我们可以将一个派生类对象的指针
   存储在一个基类的智能指针内。
22.当我们使用存在继承关系的类型时，必须将一个变量或其他表达式的静态类型(static type)与该表达式表示
   对象的动态类型(dynamic type)区分开来。表达式的静态类型在编译时总是已知的，它是变量声明时的类型或
   表达式生成的类型；动态类型则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才可知。
   如果表达式既不是引用又不是指针，则它的动态类型永远与静态类型一致。
23.当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动
   或赋值，它的派生类部分将被忽略掉。
24.存在继承关系的类型之间的转换规则
   要想理解在具有继承关系的类之间发生的类型转换，有三点非常重要：
	・从派生类向基类的类型转换只对指针或引用类型有效。
	・基类向派生类不存在隐式类型转换。
	・和任何其他成员一样，派生类向基类的类型转换也可能会由于访问受限而变得不可行。
	尽管自动类型转换只对指针或引用类型有效，但是集成体系中的大多数类仍然（显示或隐式地）定义了拷贝
	控制成员。因此，我们通常能够将一个派生类对象拷贝、移动或赋值给一个基类对象。不过需要注意的是，
	这样的操作只处理派生类对象的基类部分。
25.通常情况下，如果我们不使用某个函数，则无需为该函数提供定义。但是我们必须为每个虚函数都提供定义，
   而不管它是否被用到了，这是因为连编译器也无法确定到底会使用哪个虚函数。
26.当我们在派生类中覆盖了某个虚函数时，可以再一次使用virtual关键字指出该函数的性质。然后这么做并
   非必须，因为一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。一个派生类的函数如果覆盖了
   某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致。同样，派生类中虚函数的返回
   类型也必须与基类函数匹配。该规则存在一个例外，当类的虚函数返回类型是类本身的指针或引用时，上述
   规则无效。也就是说，如果D由B派生得到，则基类的虚函数可以返回B*而派生类的对应函数可以返回D*，只不过
   这样的返回类型要求从D到B的类型转换是可访问的。
27.override说明符：派生类如果定义了一个函数与基类中虚函数的名字相同但是形参列表不同，这仍然是合法的
   行为。编译器将认为新定义的这个函数与基类中原有的函数是相互独立的。这时，派生类的函数并没有覆盖掉
   基类中的版本。就实际的编程习惯而言，这种声明往往意味着发生了错误，因为我们可能原本希望派生类能覆盖
   掉基类中的虚函数，但是一不小心把形参列表弄错了。
     在C++11新标准中我们可以使用override关键字来说明派生类中的虚函数。这么做的好处是在使得程序员的意图
   更加清晰的同时让编译器可以为我们发现一些错误，后者在编程实践中显得更加重要。如果我们使用override标记
   了某个函数，但该函数并没有覆盖已存在的虚函数，因此编译器将报错。
29.我们还能把某个函数指定为final，如果我们已经把函数定义成final了，则之后任何尝试覆盖该函数的操作都
   将引发错误。final和override说明符出现在形参列表(包括任何const或引用修饰符)以及尾置返回类型之后。
30.虚函数与默认实参
   和其它函数一样，虚函数也可以拥有默认实参。如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型
   决定。换句话说，如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的
   是派生类中的函数版本也是如此。此时，传入派生类函数的将是基类函数定义的默认实参。如果派生类函数依赖
   不同的实参，则程序结果将与我们的预期不符。所以，如果虚函数使用默认实参，则基类和派生类中定义的默认
   参数最好一致。
31.在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。使用
   作用域运算符可以实现这一目的，例如下面的代码：
   double undiscounted = baseP->Quote::net_price(42);
   通常情况下，只有成员函数（或友元）中的代码才需要使用作用域运算符来回避虚函数的机制。
32.纯虚函数
	1）一个纯虚函数无需定义。我们通过在函数体的位置（即在声明语句的分号之前）书写=0就可以将一个虚函数
	说明为纯虚函数。其中，=0只能出现在类内部的虚函数声明语句处。
	2）值得注意的是，我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。也就是说，我们不能
	在类的内部为一个=0的函数提供函数体。
33.含有（或者未经覆盖直接继承）纯虚函数的类是抽象基类（abstract base class）。抽象基类负责定义接口，
   而后续的其他类可以覆盖该接口。我们不能（直接）创建一个抽象基类的对象。
34.受保护的成员，一个类使用protected关键字来声明那些它希望与派生类分享但是不想被其他公共访问使用的成员。
	1）和私有成员类似，受保护的成员对于类的用户来说是不可访问的。
	2）和公有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的。
	3）此外，protected还有另外一条重要的性质。派生类的成员或友元只能通过派生类对象来访问基类的受保护成员
	。派生类对于一个基类对象中的保护成员没有任何访问特权。
35.共有、私有和受保护继承
	1）某个类对其继承而来的成员的访问权限受到两个因素影响：一是在基类中该成员的访问说明符，二是在派生类
	的派生列表中的访问说明符。
	2）派生访问说明符对于派生类的成员（及友元）能否访问其直接基类的成员没什么影响。对基类成员的访问权限只
	与基类中的访问说明符有关。
	3）派生访问说明符的目的是控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限，如果继承是
	公有的，则成员将遵循其原有的访问说明符。如果继承是私有的，继承自基类的所有成员都是私有的，派生类的用户
	将不能访问。如果继承是保护的，则基类的所有公有成员在新定义的类中都是受保护的，保护成员将变为私有的。
36.派生类向基类转换的可访问性
   派生类向基类的转换是否可访问由使用该转换的代码决定，同时派生类的派生访问说明符也会有影响。假定D继承自B:
   ・只有当D公有地继承B时，用户代码才能使用派生类向基类的转换；如果D继承B的方式是受保护的或者私有的，则
     用户代码不能使用该转换。
   ・不论D以什么方式继承B，D的成员函数和友元都能使用派生类向基类的转换；派生类向其直接基类的类型转换对于
     派生类的成员和友元来说永远是可访问的。
   ・如果D继承B的方式是公有的或者受保护的，则D的派生类的成员和友元可以使用D向B的类型转换；反之，如果D
     继承B的方式是私有的，则不能使用。
37.友元关系不能传递，友元关系同样也不能继承。基类的友元在访问派生类成员时不具有特殊性，类似的，派生类
   的友元也不能随意访问基类的成员。
38.改变个别成员的可访问性
   class Base {
		public：
		    std::size_t size() const { return n; }
		protected:
			std::size_t n;
   };
   class Derived:private Base{          // 注意：private继承
		public:
			// 保持对象尺寸相关的成员的访问级别
			using Base::size;
		protected:
			using Base::n;
   };
   通过在类的内部使用using声明语句，我们可以将改类的直接或间接基类中的任何可访问成员（例如，非私有成员）
   标记出来。using声明语句中名字的访问权限由该using声明语句之前的访问说明符来决定。
39.默认的继承保护级别
   使用struct和class关键字定义的类具有不同的默认访问说明符。类似的，默认派生运算符也由定义派生类所用
   的关键字来决定。默认情况下，使用class关键字定义的派生类是私有继承的；而使用struct关键字定义的派生类
   是公有继承的。
   人们常常有一种错觉，认为在使用struct关键字和class关键字定义的类之间还有更深层次的差别。事实上，唯一的
   差别就是默认成员访问说明符及默认派生访问说明符；除此之外，再无其他不同之处。
40.继承中的类作用域
   1）每个类定义自己的作用域，在这个作用域内我们定义类的成员。当存在继承关系时，派生类的作用域嵌套在
     其基类的作用域之内。如果一个名字在派生类的作用域内无法正确解析，则编译器将继续在外层的基类作用域
	 中寻找该名字的定义。
   2）派生类的作用域位于基类作用域之内这一实事可能有点出人意料，毕竟在我们的程序文本中派生类和基类的定义
     定义是相互分离开来的。不过也恰恰因为类作用域有这种继承嵌套的关系，所以派生类才能像使用自己的成员
	 一样使用基类的成员。
   3）和其它作用域一样，派生类也能重用定义在其直接基类或间接基类中的名字，此时定义在内层作用域（即派生类）
     的名字将隐藏定义在外层作用域（即基类）的名字。
   4）我们可以通过作用域运算符来使用一个被隐藏的基类成员，作用域运算符将覆盖掉原有的查找规则，并指示编译器从
     Base类的作用域开始查找。
   5）除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字。
   6）关键概念：名字查找与继承
     理解函数调用的解析过程对于理解C++的继承至关重要，假定我们调用p->mem()（或者obj.men()），则依次执行以下
     4个步骤：
     ・首先确定p（或obj）的静态类型。因为我们调用的是一个成员，所以该类型必然是类类型。
	 ・在p（或obj）的静态类型对应的类中查找mem。如果找不到，则依次在直接基类中不断查找直至到达继承链的顶端。
	   如果找遍了该类及其基类仍然找不到，则编译器将报错。
	 ・一旦找到了mem，将进行常规的类型检查以确认对于当前找到的mem，本次调用是否合法。
	 ・假设调用合法，则编译器将根据调用的是否是虚函数而产生不通的代码：
		-- 如果mem是虚函数且我们是通过引用或指针进行的调用，则编译器产生的代码将在运行时确定到底运行该虚函数
		   的哪个版本，依次是对象的动态类型。
		-- 反之，如果mem不是虚函数或者我们是通过对象（而非引用或指针）进行的调用，则编译器将产生一个常规函数调用。
   7）一如既往，名字查找先于类型检查
      如前所述，声明在内层作用域的函数并不会重载声明在外层作用域的函数。因此，定义派生类中的函数也不会
	  重载其基类中的成员。和其他作用域一样，如果派生类（即内层作用域）的成员与基类（即外层作用域）的某个
	  成员同名，则派生类将在其作用域内隐藏该基类成员。即使派生类成员和基类成员的形参列表不一致，基类成员
	  也仍然会被屏蔽掉。
   8）和其它函数一样，成员函数无论是否是虚函数都能被重载。派生类可以覆盖重载函数的0个或多个实例。如果
      派生类希望所有的重载版本对于它来说都是可见的，那么它就需要覆盖所有的版本，或者一个也不覆盖。有时
	  一个类仅需覆盖重载集合中的一些而非全部函数，一种好的解决方案是为重载的成员提供一条using声明语句
	  ，这样我们就无须覆盖基类中的每一个重载版本了。using声明语句制定一个名字而不指定形参列表，所以一条
	  基类成员函数的using声明语句就可以把该函数的所有重载实例添加到派生类作用域中。此时，派生类只需要定义
	  其特有的函数就可以了，而无须为继承而来的其它函数重新定义。类内using声明的一般规则同样适用于重载函数
	  的名字；基类函数的每个实例在派生类中都必须是可访问的。对派生类没有重新定义的重载版本的访问实际上是
	  对using声明点的访问。
41. 构造函数与拷贝控制
   1）虚析构函数
      继承关系对基类拷贝控制最直接的影响是基类通常应该定义一个虚析构函数，这样我们就能动态分配继承体系中的
	  对象了。如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。
   2）某些定义基类的方式也可能导致有的派生类成员成为被删除的函数：
      ・如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或者不可访问，则
	    派生类中对应的成员将是被删除的，原因是编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值
		或销毁操作。
	  ・如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的，因为
	    编译器无法销毁派生类对象的基类部分。
	  ・和过去一样，编译器将不会合成一个删除掉的移动操作。当我们使用=default请求一个移动操作时，如果基类中
	    的对应操作是删除的或不可访问的，那么派生类中该函数将是被删除的，原因是派生类对象的基类部分不可移动。
		同样，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是被删除的。
   3）派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员。类似的，派生类
      赋值运算符也必须为其基类部分的成员赋值。和构造函数及赋值运算符不同的是，析构函数只负责销毁派生类自己
	  分配的资源。
   4）在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝（或移动）基类部分，则必须
      在派生类的构造函数初始值列表中显式地使用基类的拷贝（或移动）构造函数。
	  与拷贝和移动构造函数一样，派生类的赋值运算符也必须显式地为其基类部分赋值。值得注意是，无论基类的
	  构造函数或赋值运算符是自定义的版本还是合成的版本，派生类的对应操作都能使用它们。
   5）派生类析构函数
      在析构函数体执行完成后，对象的成员会被隐式销毁。类似的，对象的基类部分也是隐式销毁的。因此，和
	  构造函数及赋值运算符不同的是，派生类析构函数只负责销毁由派生类自己分配的资源。
   6）如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。
   7）在C++11新标准中，派生类能够重用其直接基类定义的构造函数。一个类只初始化它的直接基类，出于同样的原因
      ，一个类也只继承其直接基类的构造函数。类不能继承默认、拷贝和移动构造函数。如果派生类没有直接定义
	  这些构造函数，则编译器将为派生类合成它们。
   8）派生类继承基类构造函数的方式是提供一条注明了（直接）基类名的using声明语句。举个例子
      class Bulk_quote : public Disc_quote {
		public:
			using Disc_quote::Disc_quote;  // 继承Disc_quote的构造函数
			double net_price(std::size_t) const;
	  }
	  通常情况下，using声明语句只是令某个名字在当前作用域内可见。而当作用于构造函数时，using声明语句将
	  令编译器产生代码。对于基类的某个构造函数，编译器都生成一个与之对应的派生类构造函数。换句话说，对于
	  基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数。
		这些编译器生成的构造函数形如：
		derived(parms) : base(args) {}
	  在我们的Bulk_quote类中，继承构造函数等价于：
	    Bulk_quote(const std::string& book, double price, std::size_t qty, double disc):
			Disc_quote(book, price, qty, disc) { }
		如果派生类含有自己的数据成员，则这些成员将被默认初始化。
   9）继承的构造函数的特定
      ・和普通成员的using声明不一样，一个构造函数的using声明不会改变该构造函数的访问级别。
	  ・而且，一个using声明语句不能指定explicit或constexpr。如果基类的构造函数是explicit或者constexpr，
	    则继承的构造函数也拥有相同的属性。
	  ・当一个基类构造函数含有默认实参时，这些实参并不会被继承。相反，派生类将获得多个继承的构造函数，其中
	    每个构造函数分别省略掉一个含有默认实参的形参。
	  ・如果基类含有几个构造函数，则除了两个例外情况，大多数时候派生类会继承所有这些构造函数。第一个例外
	    是派生类可以继承一部分构造函数，而为其他构造函数定义自己的版本。第二个例外是默认、拷贝和移动构造函数
		不会被继承。
42.容器和继承
   1）当我们使用容器存放继承体系中的对象时，通常必须采用间接存储的方式。因为不允许在容器中保存不同类型
      的元素，所以我们不能把具有继承关系的多种类型的对象直接存放在容器当中。
   2）当派生类对象被赋值给基类对象时，其中的派生类部分将被“切掉”，因此容器和存在继承关系的类型无法兼容。
   3）当我们希望在容器中存放具有继承关系的对象时，我们实际上存放的通常是基类的指针（更好的选择是智能指针）。
      和往常一样，这些指针所指对象的动态类型可能是基类类型，也可能是派生类类型。
*/
