#pragma once
/*
1. 面向对象程序设计（object-oriented programming）的核心思想是数据抽象、继承和动态绑定。
   1）通过使用数据抽象，我们可以将类的接口与实现分离；
   2）使用继承，可以定义相似的类型并对其相似关系建模；
   3）使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。
2. 在C++语言中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的
   派生类各自定义适合自身的版本，此时基类就将这些函数声明成虚函数(virtual function)。
3. 在C++语言中，当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。
4. 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。
5. 任何构造函数之外的非静态函数都可以是虚函数。关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的
   函数定义。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。
6. 成员函数如果没被声明为虚函数，则其解析过程发生在编译时而非运行时。
7. 派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。和其他使用
   基类的代码一样，派生类能访问公有成员，而不能访问私有成员。不过在某些时候基类中还有这样一种成员，基类
   希望它的派生类有权访问该成员，同时禁止其他用户访问。我们用受保护的（protected）访问运算符说明这样的成员。
8. 派生类必须通过使用类派生列表（class derivation list）明确指出它是从哪个（哪些）基类继承而来的。类派生列表
   的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有以下三种访问说明符中的一个：
   pubilc、protected或者private。
9. 派生类经常（但不总是）覆盖它继承的虚函数。如果派生类没有覆盖其基类的某个虚函数，则该虚函数的行为类似于
   其他的普通函数，派生类会直接继承其在基类中的版本。
   派生类可以在它覆盖的函数前使用virtual关键字，但不是非得这么做。C++新标准允许派生类显式地注明它使用某个
   成员函数覆盖了它继承的虚函数。具体做法是在形参列表后面、或者在const成员函数的const关键字后面、或者在引用
   成员函数的引用限定符后面添加一个关键字override。
10.一个派生类对象包含多个组成部分：一个含有派生类自己定义的（非静态）成员的子对象，以及一个与该派生类
   继承的基类对应的子对象，如果有多个基类，那么这样的子对象也有多个。
11.C++标准并没有明确规定派生类的对象在内存中如何分布，但是我们可以认为包含如果所示两部分
                                     Bulk_quote对象
			从Quote继承而来的成员   -----------------
									  bookNo
									  price
									-----------------
			Bulk_quote自定义的成员	  min_qty
									  discount
									-----------------
			在一个对象中，继承自基类的部分和派生类自定义的部分不一定是连续存储的。
   因为在派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当作基类对象来使用，而且我们
   也能将基类的指针或引用绑定到派生类对象中的基类部分上。编译器会隐式地执行派生类到基类的转换。
12.在派生类对象中含有与其基类对应的组成部分，这一事实是继承的关键所在。
13.尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的
   代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分。即每个类控制它自己的成员初始化过程。
14.派生类构造函数同样是通过构造函数初始化列表来将实参传递给基类构造函数的。例如，接受四个参数的Bulk_quote
   构造函数如下所示：
       Bulk_quote(const std::string& book, double p,
	              std::size_t qty, double disc) :
				  Quote(book, p), min_qty(qty), discount(disc){}
   除非我们特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化。
   首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。
*/
