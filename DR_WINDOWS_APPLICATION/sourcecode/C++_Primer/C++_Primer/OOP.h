#pragma once
/*
1. 面向对象程序设计（object-oriented programming）的核心思想是数据抽象、继承和动态绑定。
   1）通过使用数据抽象，我们可以将类的接口与实现分离；
   2）使用继承，可以定义相似的类型并对其相似关系建模；
   3）使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。
2. 在C++语言中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的
   派生类各自定义适合自身的版本，此时基类就将这些函数声明成虚函数(virtual function)。
3. 在C++语言中，当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。
4. 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。
5. 任何构造函数之外的非静态函数都可以是虚函数。关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的
   函数定义。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。
6. 成员函数如果没被声明为虚函数，则其解析过程发生在编译时而非运行时。
7. 派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。和其他使用
   基类的代码一样，派生类能访问公有成员，而不能访问私有成员。不过在某些时候基类中还有这样一种成员，基类
   希望它的派生类有权访问该成员，同时禁止其他用户访问。我们用受保护的（protected）访问运算符说明这样的成员。
8. 派生类必须通过使用类派生列表（class derivation list）明确指出它是从哪个（哪些）基类继承而来的。类派生列表
   的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有以下三种访问说明符中的一个：
   pubilc、protected或者private。
9. 派生类经常（但不总是）覆盖它继承的虚函数。如果派生类没有覆盖其基类的某个虚函数，则该虚函数的行为类似于
   其他的普通函数，派生类会直接继承其在基类中的版本。
   派生类可以在它覆盖的函数前使用virtual关键字，但不是非得这么做。C++新标准允许派生类显式地注明它使用某个
   成员函数覆盖了它继承的虚函数。具体做法是在形参列表后面、或者在const成员函数的const关键字后面、或者在引用
   成员函数的引用限定符后面添加一个关键字override。
10.一个派生类对象包含多个组成部分：一个含有派生类自己定义的（非静态）成员的子对象，以及一个与该派生类
   继承的基类对应的子对象，如果有多个基类，那么这样的子对象也有多个。
11.C++标准并没有明确规定派生类的对象在内存中如何分布，但是我们可以认为包含如果所示两部分
                                     Bulk_quote对象
			从Quote继承而来的成员   -----------------
									  bookNo
									  price
									-----------------
			Bulk_quote自定义的成员	  min_qty
									  discount
									-----------------
			在一个对象中，继承自基类的部分和派生类自定义的部分不一定是连续存储的。
   因为在派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当作基类对象来使用，而且我们
   也能将基类的指针或引用绑定到派生类对象中的基类部分上。编译器会隐式地执行派生类到基类的转换。
12.在派生类对象中含有与其基类对应的组成部分，这一事实是继承的关键所在。
13.尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的
   代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分。即每个类控制它自己的成员初始化过程。
14.派生类构造函数同样是通过构造函数初始化列表来将实参传递给基类构造函数的。例如，接受四个参数的Bulk_quote
   构造函数如下所示：
       Bulk_quote(const std::string& book, double p,
	              std::size_t qty, double disc) :
				  Quote(book, p), min_qty(qty), discount(disc){}
   除非我们特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化。
   首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。
15.派生类可以访问基类的公有成员和受保护成员，派生类的作用域嵌套在基类的作用域之内。因此，对于派生类的一个成员
   来说，它使用派生类成员的方式与使用基类成员的方式没有什么不同。
16.如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，
   对于每个静态成员来说都只存在唯一的实例。
17.派生类的声明与其他类差别不大，声明中包含类名但是不包含它的派生列表。一条声明语句的目的是令程序知晓
   某个名字的存在以及该名字表示一个什么样的实体，如一个类、一个函数或一个变量等。
18.如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明。这一规定的原因显而易见：派生类中包含
   并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类当然要知道它们是什么。
19.C++11新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字final。
20.理解基类和派生类之间的类型转换是理解C++语言面向对象编程的关键所在。
21.可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义：当使用基类的引用（或指针）时，实际上
   我们并不清楚该引用（或指针）所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。
   和内置指针一样，智能指针类也支持派生类向基类的类型转换，这意味着我们可以将一个派生类对象的指针
   存储在一个基类的智能指针内。
22.当我们使用存在继承关系的类型时，必须将一个变量或其他表达式的静态类型(static type)与该表达式表示
   对象的动态类型(dynamic type)区分开来。表达式的静态类型在编译时总是已知的，它是变量声明时的类型或
   表达式生成的类型；动态类型则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才可知。
   如果表达式既不是引用又不是指针，则它的动态类型永远与静态类型一致。
23.当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动
   或赋值，它的派生类部分将被忽略掉。
24.存在继承关系的类型之间的转换规则
   要想理解在具有继承关系的类之间发生的类型转换，有三点非常重要：
	・从派生类向基类的类型转换只对指针或引用类型有效。
	・基类向派生类不存在隐式类型转换。
	・和任何其他成员一样，派生类向基类的类型转换也可能会由于访问受限而变得不可行。
	尽管自动类型转换只对指针或引用类型有效，但是集成体系中的大多数类仍然（显示或隐式地）定义了拷贝
	控制成员。因此，我们通常能够将一个派生类对象拷贝、移动或赋值给一个基类对象。不过需要注意的是，
	这样的操作只处理派生类对象的基类部分。
*/
