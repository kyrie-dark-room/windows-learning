#pragma once
/*
------------------------------------------------------------------------------------------------------
										信息点
------------------------------------------------------------------------------------------------------
	1. 定义在类内部的函数是隐式地inline函数。
	2. 成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求
	该函数的对象地址初始化this。
	3. 函数紧随参数列表之后是const关键字，作用是修改隐式this指针的类型。
		C++语言的做法是允许把const关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的const表示
		this是一个指向常量的指针。像这样使用const的成员函数被称作常量成员函数。
	4. 编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体（如果有的话）。因此，成员函数体可以
	随意使用类中的其他成员而无须在意这些成员出现的次序。
	5. 如果成员声明成常量成员函数，那么它的定义也必须在参数列表后明确指定const属性。同时，类外部定义的
	成员的名字必须包含它所属的类名。
	6. 构造函数
		（1）构造函数的名字和类名相同。和其他函数不一样的是，构造函数没有返回类型。
		（2）不同于其他成员函数，构造函数不能被声明成const的。当我们创建类的一个const对象时，直到构造
		函数完成初始化过程，对象才能真正取得其“常量”属性。因此，构造函数在const对象的构造过程中可以
		向其写值。
		（3）如果我们的类没有显示地定义构造函数，那么编译器就会为我们隐式地定义一个默认构造函数。编译器
		创建的构造函数又被称为合成的默认构造函数。对于大多数类来说，这个合成的默认构造函数将按照如下规则
		初始化类的数据成员：
			・如果存在类内的初始值，用它来初始化成员。
			・否则，默认初始化该成员。
		（4）合成的默认构造函数只适合非常简单的类，对于一个普通的类来说，必须定义它自己的默认构造函数，
		原因有三：
			> 编译器只有在发现类不包含任何构造函数的情况下才会替我们生成一个默认构造函数。
			> 对于某些类来说，合成的默认构造函数可能执行错误的操作。如果类包含有内置类型或者复合类型的
			成员，则只有当这些成员全都被赋予了类内的初始值时，这个类才适合于使用合成的默认构造函数。
			> 编译器不能为某些类合成默认的构造函数。例如，如果类中包含一个其他类类型的成员且这个成员的
			类型没有默认构造函数，那么编译器将无法初始化该成员。
		（5）在C++11新标准中，如果我们需要默认的行为，那么可以通过在参数列表后面写上= default来要求
		编译器生成构造函数。其中，= default既可以和声明一起出现在类的内部，也可以作为定义出现在类的外部。
		= default函数特性仅适用于类的特殊成员函数，且该特殊成员函数没有默认参数。
		（6）构造函数初始值列表
			example:
			Sales_date(const std::string &s, unsigned n, double p):
						bookNo(s), units_sold(n), revenue(p*n){}
		（7）编译器为类构造的6个默认函数
			・默认构造函数
			・默认拷贝构造函数
			・默认赋值构造函数
			・默认析构函数
			・一对取址运算符
	7. 使用class和struct定义类唯一的区别就是默认的访问权限，如果使用struct关键字，则定义在第一个
		访问说明符之前的成员是public的；相反，如果我们使用class关键字，则这些成员是private的。
	8. 友元
		・类可以允许其他类或者函数访问它的非公有成员，方法是领其他类或者函数称为它的友元
		・如果类想把一个函数作为它的友元，只需要增加一条以friend关键字开始的函数声明语句即可
		・友元声明只能出现在类的内部，但是在类内出现的具体位置不限。友元不是类的成员也不受它所在
		区域访问控制级别的约束。一般来说，最好在类定义开始或结束前的位置集中声明友元
		・友元的声明仅仅制定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够
		调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明
	9. 令成员作为内联函数
		・定义在类内部的成员函数是自动inline的
		・我们可以在类的内部把inline作为声明的一部分显式地声明成员函数
		・同样的，也能在类的外部用inline关键字修饰函数的定义
	10. 可变数据成员
		有时（但并不频繁）会发生这样一种情况，我们希望能修改类的某个数据成员，即使是在一个const成员
		函数内，可以通过在变量的声明中加入mutable关键字做到这一点。一个可变数据成员(mutable data member)
		永远不会是const，即使它是const对象的成员。
	11. 一个const成员函数如果以引用的形式返回*this，那么它的返回类型将是常量引用
	12. 基于const的重载
		通过区分成员函数是否是const的，我们可以对其进行重载，其原因与我们之前根据指针参数是否指向
		const而重载函数的原因差不多，具体说来，因为非常量版本的函数对于常量对象时不可用的，所以我们
		只能在一个常量对象上调用const成员函数。另一方面，虽然可以在非常量对象上调用常量版本或非常量
		版本，但显然此时非常量版本是一个更好的匹配。
	13. 我们可以把类名作为类型的名字使用，从而直接指向类类型。或者，我们也可以把类名跟在关键字class
		或struct后面。
		・Sales_data item1;            // 默认初始化Sales_date类型的对象
		・class Sales_data item1;      // 一条等价的声明
	14. 不完全类型
		我们可以仅声明类而暂时不定义它：
		class Screen;   // Screen类的声明
		这种声明有时被称作前向声明(forward declaration)，它向程序中引入了名字Screen并且指明Screen是
		一种类类型。对于类型Screen来说，在它声明之后定义之前是一个不完全类型。
		不完全类型只能在非常有限的情景下使用：可以定义指向这种类型的指针或引用，也可以声明(但是不能定义)
		以不完全类型作为参数或者返回类型的函数。
	15. 类还可以把其他的类定义成友元，也可以把其他类（之前已定义过的）的成员函数定义成友元。此外，
		友元函数能定义在类的内部，这样的函数是隐式内联的。必须要注意的一点是，友元关系不存在传递性，即
		每个类负责控制自己的友元类或者友元函数。
	16. 编译器处理完类中的全部声明后才会处理成员函数的定义。
	17. 成员函数中使用的名字按照如下方式解析：
		（1）首先，在成员函数内查找改名字的声明。和前面一样，只有在函数使用之前出现的声明才被考虑。
		（2）如果在成员函数内没有找到，则在类内继续查找，这时类的所有成员都可以被考虑。
		（3）如果类内也没找到改名字的声明，在成员函数定义之前的作用域内继续查找。
	18. 隐藏数据的访问
		（1）如果类的成员被局部变量隐藏，我们仍然可以通过加上类的名字或显示地使用this指针来强制访问成员。
		     void Screen:: dummy_fcn(pos height){
				cursor = width * this->height;    // 成员height
				// 另外一种表示该成员的方式
				cursor = width * Screen::height;  // 成员height
			 }
		（2）如果外层的对象被隐藏掉了，我们仍然可以通过用作用域运算符访问它。
			void Screen:: dummy_fcn(pos height){
				cursor = width * ::height;   // 哪个height? 是哪个全局的
			 }
	19. 构造函数初始值列表
		（1）如果没有在构造函数的初始值列表中显示地初始化成员，则该成员将在构造函数体之前执行默认初始化。
		（2）有时我们可以忽略数据成员初始化和赋值之间的差异，但并非总能这样。如果成员是const或者引用的话，
		必须将其初始化。类似的，当成员属于某种类类型且该类没有定义默认构造函数时，也必须将这个成员初始化。
		（3）在很多类中，初始化和赋值的区别事关底层效率问题：前者直接初始化数据成员，后者则先初始化再赋值。
		（4）不过让人稍感意外的是，构造函数初始值列表只说明用于初始化成员的值，而不限定初始化的具体执行顺序。
		成员的初始化顺序与它们在类定义中的出现顺序一致。
		（5）如果一个构造函数为所有参数都提供了默认参数，则它实际上也定义了默认构造函数。
	20. 委托构造函数（C++11）
		（1）一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些
		（或者全部）职责委托给其他构造函数。
		  example:
		  class Sales_data{
		  public:
			// 非委托构造函数使用对应的实参初始化成员
			Sales_data(std::string s, unsigned cnt, double price): bookNo(s), units_sold(cnt), revenue(cnt* price){}
			// 其余构造函数全部委托给另一个构造函数
			Sales_data(): Sales_data("", 0, 0){}
			Sales_data(std::string s): Sales_data(s, 0, 0){} 
			Sales_data(std::istream &is): Sales_data(){ read(is, *this); }
		  }
		（2）当一个构造函数委托给另个构造函数时，受委托的构造函数的初始值列表和函数体被一次执行。
	21. 隐式的类类型转换
		（1）能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则。
		（2）编译器只会自动地执行一步类型转换。
		（3）在要求隐式转换的程序上下文中，我们可以通过将构造函数声明为explicit加以阻止：
			・关键字explicit只对一个实参的构造函数有效。
			・只能在类内声明构造函数时使用explicit关键字，在类外部定义时不应重复。
			・尽管编译器不会讲explicit的构造函数用于隐式转换过程，但是我们可以使用这样的构造函数显式
			地强制进行转换。
	22. 聚合类
		聚合类使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。当一个类满足如下条件时，我们说它
		是聚合的：
		（1）所有成员都是public的。
		（2）没有定义任何构造函数。
		（3）没有类内初始值。
		（4）没有基类，也没有virtual函数。
	23. 字面值常量类
		（1）数据成员都是字面值类型的聚合类是字面值常量类。
		（2）如果一个类不是聚合类，但它符合下述要求，则它也是一个字面值常量类：
			・数据成员都是必须是字面值类型
			・类必须至少含有一个constexpr构造函数
			・如果一个数据成员含有类内初始化，则内置类型成员的初始值必须是一条常量表达式；或者如果成员
			属于某种类类型，则初始值必须使用成员自己的constexpr构造函数
			・类必须使用析构函数的默认定义，该成员负责销毁类的对象。
		（3）constexpr构造函数
			・constexpr构造函数必须初始化所有数据成员，初始值或者使用constexpr构造函数，或者是一条常量表达式
			・constexpr构造函数用于生成constexpr对象以及constexpr函数的参数或返回类型。
	24. 类的静态成员
		（1）我们可以使用作用域运算符直接访问静态成员，虽然静态成员不属于类的某个对象，但是我们仍然可以
		使用类的对象、引用或者指针来访问静态成员。
		（2）在类的外部定义静态成员时，不能重复static关键字，该关键字只出现在类内部的声明语句。
		（3）一般来说，我们不能在类的内部初始化静态成员。相反的，必须在类的外部定义和初始化每个静态成员。
		（4）即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员。
------------------------------------------------------------------------------------------------------
*/
