#pragma once
/*
1. 标准库提供8个关联容器：
   -------------------------------------------------------------------------------------------------
											关联容器类型
   -------------------------------------------------------------------------------------------------
   按关键字有序保存元素
   map							关联数组；保存关键字-值对
   set							关键字即值，即只保存关键字的容器
   multimap						关键字可重复出现的map
   multiset						关键字可重复出现的set
   无序集合
   unordered_map				用哈希函数组织的map
   unordered_set				用哈希函数组织的set
   unordered_multimap			哈希组织的map；关键字可以重复出现
   unordered_multiset			哈希组织的set；关键字可以重复出现
   -------------------------------------------------------------------------------------------------
2. 关联容器的迭代器都是双向的。
3. 关联容器对其关键字类型有一些限制。
   (1) 对于有序容器----map、multimap、set以及multiset，关键字类型必须定义元素比较的方法。默认情况下，
	   标准库使用关键字类型的<运算符来比较两个关键字。
   (2) 对于无序容器：见19.
4. 我们可以提供自己定义的操作来代替关键字上的<运算符。所提供的操作必须在关键字类型上定义一个严格弱序
   (strict weak ordering)。可以将严格弱序看作“小于等于”，虽然实际定义的操作可能是一个复杂的函数。无论
   我们怎样定义比较函数，它必须具备如下基本性质：
   ・两个关键字不能同时“小于等于”对方；如果k1“小于等于”k2，那么k2绝不能“小于等于”k1。
   ・如果k1“小于等于”k2，且k2“小于等于”k3，那么k1必须“小于等于”k3。
   ・如果存在两个关键字，任何一个都不“小于等于”另一个，那么我们称这两个关键字是“等价”的。如果k1
    “等价于”k2，且k2“等价于”k3，那么k1必须“等价于”k3。
5. 为了使用自己定义的操作，在定义multiset时，我们必须提供两个类型：关键字类型Sales_date，以及比较操作
   类型--应该是一种函数指针类型，可以指向compareIsbn。
   example
    multiset<Sales_data, decltype(compareIsbn)*> bookstore(compareIsbn);
	此处，我们使用decltype来指出自定操作的类型。记住，当用decltype来获得一个函数指针类型时，必须加上一个
	*来指出我们要使用一个给定函数类型的指针。用compareIsbn来初始化cookstore对象，这表示当我们向bookstore
	添加元素时，通过调用compareIsbn来为这些元素排序。
6. pair是标准库中的类型，定义在头文件utility中。一个pair保存两个数据成员。类似容器，pair是一个用来生成
   特定类型的模板。当创建一个pair时，我们必须提供两个类型名，pair的数据成员将具有对应的类型。
7. -------------------------------------------------------------------------------------------------
										pair上的操作
   -------------------------------------------------------------------------------------------------
   pair<T1, T2> p;				p是一个pair，两个类型分别为T1和T2的成员都进行了值初始化
   pair<T1, T2> p(v1, v2);      p是一个成员类型为T1和T2的pair；first和second成员分别用v1和v2进行初始化
   pair<T1, T2> p = {v1, v2};   等价于p(v1, v2)
   make_pair(v1, v2)			返回一个用v1和v2初始化的pair。pair的类型从v1和v2的类型推断出来
   p.first						返回p的名为first的（公有）数据成员
   p.second						返回p的名为second的（公有）数据成员
   p1 relop p2					关系运算符（<、>、<=、>=）按字典序定义：例如，当p1.first < p2.first或
								!(p2.first < p1.first) && p1.second < p2.second成立时，p1 < p2为true。
								关系运算符利用元素的<运算符来实现。
   p1 == p2						当first和second成员分别相等时，两个pair相等。相等性判断利用元素的==
   p1 != p2						运算符实现。
   -------------------------------------------------------------------------------------------------
8. 关联容器还定义了表示容器关键字和值的类型：
   -------------------------------------------------------------------------------------------------
										关联容器额外的类型别名
   -------------------------------------------------------------------------------------------------
   key_type				此容器类型的关键字类型
   mapped_type			每个关键字关联的类型；只适用于map
   value_type			对于set，与key_type相同
						对于map，为pair<const key_type，mapped_type>
   -------------------------------------------------------------------------------------------------
9. map元素的关键字和set中的关键字一样，都是const的，不能修改。
10. 当使用一个迭代器遍历一个map、multimap、set或multiset时，迭代器关键字升序遍历元素。
11. 向一个map插入元素的4种方法：
	(1) word_count.insert({word, 1});
	(2) word_count.insert(make_pair(word, 1));
	(3) word_count.insert(pair<string, size_t>(word, 1));
	(4) word_count.insert(map<string, size_t>::value_type(word, 1));
12. 关联容器insert操作
	------------------------------------------------------------------------------------------------
										关联容器insert操作
	------------------------------------------------------------------------------------------------
	c.insert(v)			v是value_type类型的对象；args用来构造一个元素
	c.emplace(args)		对于map和set，只有当元素的关键字不在c中时才插入（或构造）元素。函数返回一个
						pair，包含一个迭代器，指向具有指定关键字的元素，以及一个指示插入是否成功的
						bool值。对于multimap和multiset，总会插入（或构造）给定元素，并返回一个指向新
						元素的迭代器。
	c.insert(b, e)      b和e是迭代器，表示一个c::value_type类型值的范围；il是这种值的花括号列表。函数
	c.insert(il)		返回void。对于map和set，只插入关键字不在c中的元素。对于multimap和multiset,则
						会插入范围中的每个元素。
    c.insert(p, v)      类似insert(v)（或emplace(args)），但将迭代器p作为一个提示，指出从哪里开始搜索
						应该存储的位置。返回一个迭代器，指向具有给定关键字的元素。
	------------------------------------------------------------------------------------------------
13. 从关联容器删除元素
	------------------------------------------------------------------------------------------------
										从关联容器删除元素
	------------------------------------------------------------------------------------------------
	c.erase(k)		从c中删除每个关键字为k的元素。返回一个size_type值，指出删除的元素的数量
	c.erase(p)		从c中删除迭代器p指定的元素。p必须指向一个c中一个真实元素，不能等于c.end()。返回
					一个指向p之后元素的迭代器，若p指向c中的尾元素，则返回c.end()
	c.erase(b, e)   删除迭代器对b和e所表示的范围中的元素。返回e。
	------------------------------------------------------------------------------------------------
14. map和unordered_map容器提供了下标运算符和一个对应的at函数。类似我们用过的其他下标运算符，map下标
	运算符接受一个索引（即，一个关键字），获取与此关键字相关联的值。但是，与其他下标运算符不同的是，
	如果关键字并不在map中，会为它创建一个元素并插入到map中，关联值将进行值初始化。
	------------------------------------------------------------------------------------------------
									map和unordered_map的下标操作
	------------------------------------------------------------------------------------------------
	c[k]			返回关键字为k的元素；如果k不在c中，添加一个关键字为k的元素，对其进行初始化
	c.at(k)			访问关键字k的元素，带参数检查；若k不在c中，抛出一个out_of_range异常
	------------------------------------------------------------------------------------------------
15. ------------------------------------------------------------------------------------------------
									在一个关联容器中查找元素的操作
	------------------------------------------------------------------------------------------------
	lower_bound和upper_bound不适用于无序容器。
	下标和at操作只适用于非const的map和unordered_map。
	c.find(k)			返回一个迭代器，指向第一个关键字为k的元素，若k不在容器中，则返回尾后迭代器
	c.count(k)			返回关键字等于k的元素的数量。对于不允许重复关键字的容器，返回值永远是0或1
	c.lower_bound(k)	返回一个迭代器，指向第一个关键字不小于k的元素
	c.upper_bound(k)	返回一个迭代器，指向第一个关键字大于k的元素
	c.equal_range(k)	返回一个迭代器pair，表示关键字等于k的元素的范围。若k不存在，pair的两个成员
						均等于c.end()
	------------------------------------------------------------------------------------------------
16. 新标准定义了4个无序关联容器（unordered associative container）。这些容器不是使用比较运算符来组织
	元素，而是使用一个哈希函数（hash function）和关键字类型的==运算符。在关键字类型的元素没有明显的
	序关系的情况下，无序容器是非常有用的。在某些应用中，维护元素的序代价非常高昂，此时无序容器也很有用。
17. 无序容器在存储上组织为一组桶，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。
	为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。容器将具有一个特定哈希值的所有
	元素都保存在相同的桶中。如果容器允许重复关键字，所有具有相同关键字的元素也都会在同一个桶中。因此，
	无序容器的性能依赖于哈希函数的质量和桶的数量和大小。
18. 无序容器提供了一组管理桶的函数，这些成员函数允许我们查询容器的状态以及在必要时强制容器进行重组。
	------------------------------------------------------------------------------------------------
											无序容器管理操作
	------------------------------------------------------------------------------------------------
	桶接口
	c.bucket_count()		正在使用的桶的数目
	c.max_bucket_count()	容器能容纳的最多的桶的数量
	c.bucket_size(n)		第n个桶中有多少个元素
	c.bucket(k)				关键字为k的元素在哪个桶中
	桶迭代
	local_iterator			可以用来访问桶中元素的迭代器类型
	const_local_iterator	桶迭代器的const版本
	c.begin(n)，c.end(n)	桶n的首元素迭代器和尾后迭代器
	c.cbegin(n)，c.cend(n)	与前两个函数类似，但返回const_local_iterator
	哈希策略
	c.load_factor()			每个桶的平均元素数量，返回float值
	c.max_load_factor()		c试图维护的平均桶大小，返回float值。c会在需要时添加新的桶，以使得load
							_factor<=max_load_factor
	c.rehash(n)				重组存储，使得bucket_count>=n
							且bucket_count>size/max_load_factor
	c.reserve(n)			重组存储，使得c可以保存n个元素且不必rehash
	------------------------------------------------------------------------------------------------
19. 默认情况下，无序容器使用关键字类型的==运算符来比较元素，它们还使用一个hash<key_type>类型的对象来
	生成每个元素的哈希值。标准库为内置类型（包括指针）提供了hash模板。还为一些标准库类型，包括string
	和只能指针类型定义了hash。因此，我们可以直接定义关键字是内置（包括指针类型）、string还是智能指针
	类型的无序容器。
	但是我们不能直接定义关键字类型为自定义类型的无序容器。与容器不同，不能直接使用哈希函数，而必须
	提供我们自己的hash模板版本。
	我们不使用默认的hash，而是使用另一种方法，类似于为有序容器重载关键字类型的默认比较操作。为了能将
	自定义类型Sale_data用作关键字，我们需要提供函数来替代==运算符和哈希值计算函数。我们从定义这些重载
	函数开始：
	size_t hasher(const Sales_data &sd)
	{
		return hash<string>()(sd.isbn());
	}
	bool eqOp(const Sales_data &lhs, const Sales_data &rhs)
	{
		return lhs.isbn() == rhs.isbn();
	}
	我们使用这些函数来定义一个unordered_multiset
	using SD_multiset = unordered_multiset<Sales_data, decltype(hasher)*, decltype(eqOp)*>;
	// 参数是桶大小、哈希函数指针和相等性判断运算符指针
	SD_multiset bookstore(42，hasher，eqOp);

	如果我们的类定义了==运算符，则可以只重载哈希函数：
	// 使用FooHash生成哈希值；Foo必须有==运算符
	unordered_set<Foo，decltype(FooHash)*> fooSet(10, FooHash);
*/