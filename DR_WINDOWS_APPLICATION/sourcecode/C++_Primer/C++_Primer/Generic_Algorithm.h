#pragma once
/*
1. 大多数算法都定义在头文件algorithm中。标准库还在头文件numeric中定义了一组数值泛型算法。一般情况下，
   这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。
2. 泛型算法本身不会执行容器的操作，它们只会运行于迭代器之上，执行迭代器的操作。泛型算法运行于迭代器
   之上而不会执行容器操作的特性带来了一个令人惊讶但非常必要的编程假定：算法永远不会改变底层容器的大小。
   算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素。
3. 理解算法的最基本的方法就是了解它们是否读取元素、改变元素或是重排元素顺序。
4. accumulate的第三个参数的类型决定了函数中使用哪个加法运算符以及返回值得类型。
5. 那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长。
6. 向目的位置迭代器写入数据的算法假定目的位置足够大，能容纳要写入的元素。
7. 谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。标准库算法所使用的谓词分为两类：一元谓词
   （unary predicate, 意味着它们只接受单一参数）和二元谓词（binary predicate，意味着它们有两个参数）。
   接受谓词参数的算法对输入序列中的元素调用谓词。因此，元素类型必须能转换为谓词的参数类型。
8. 在我们将words按大小重排的同时，还希望具有相同长度的元素按字典序排列。为了保持相同长度的单词按字典序
   排列，可以使用stable_sort算法。这种稳定排序算法维持相等元素的原有顺序。
9. 我们可以向一个算法传递任何类别的可调用对象(callable object)。对于一个对象或一个表达式，如果可以对
   其使用调用运算符，则称它为可调用的。
10. 四种可调用对象
	（1）函数
	（2）函数指针
	（3）重载了函数调用运算符的类
	（4）lambda表达式
11. 一个lambda表达式表示一个可调用的代码单元。我们可以将其理解为一个未命名的内联函数。与任何函数类似，
    一个lambda具有一个返回类型、一个参数列表和一个函数体。但与函数不同，lambda可能定义在函数内部。一个
	lambda表达式具有如下形式
		[capture list](parameter list) -> return type { function body }
	其中，capture list（捕获列表）是一个lambda所在函数中定义的局部变量的列表（通常为空）；return type、
	parameter list和function body与任何普通函数一样，分别表示返回类型、参数列表和函数体。但是，与普通函数
	不同，lambda必须使用尾置返回来指定返回类型。
	注意：我们可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体。
12. 如果忽略返回类型，lambda根据函数体中的代码推断出返回类型。如果函数体只是一个return语句，则返回类型
	从返回的表达式的类型推断而来。否则，返回类型为void。
	如果lambda的函数体包含任何单一return语句之外的内容，且未指定返回类型，则返回void。
13. 与普通函数不同，lambda不能有默认参数。因此，一个lambda调用的实参数目永远与形参数目相等。一旦形参
	初始化完毕，就可以执行函数体了。
14. 虽然一个lambda可以出现在一个函数中，使用其局部变量，但它只能使用那些明确指明的变量。一个lambda通过
	将局部变量包含在其捕获列表中来指出将会使用这些变量。捕获列表指引lambda在其内部包含访问局部变量所需
	的信息。
15. 捕获列表用逗号分隔。
16. 当定义一个lambda时，编译器生成一个与lambda对应的新的（未命名的）类类型。
17. 默认情况下，从lambda生成的类都包含一个对应该lambda所捕获的变量的数据成员。类似任何普通类的数据成员，
	lambda的数据成员也在lambda对象创建时被初始化。
18. 被捕获变量的值是在lambda创建时拷贝。
19. 除了显式列出我们希望使用的来自所在函数的变量之外，还可以让编译器根据lambda体中的代码来推断我们要使用
	哪些变量。为了指示编译器推断捕获列表，应在捕获列表中写一个&或=。&告诉编译器采用捕获引用方式，=则
	表示采用值捕获方式。
20. 当我们混合使用隐式捕获和显式捕获时，捕获列表中的第一个元素必须是一个&或=。此符号指定了默认捕获方式
	为引用或值。
21. 当混合使用隐式捕获和显式捕获时，显式捕获的变量必须使用与隐式捕获不同的方式。
22. 默认情况下，对于一个值被拷贝的变量，lambda不会改变其值。如果我们希望能改变一个被捕获的变量的值，就
	必须在参数列表首加上关键字mutable。因此，可变lambda能省略参数列表。
23. 一个引用捕获的变量是否（如往常一样）可以修改依赖于此引用指向的是一个const类型还是一个非const类型。
24. bind的标准库函数，它定义在头文件functional中。可以将bind函数看做一个通用的函数适配器，它接受一个
	可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。
	调用bind的一般形式为：
	auto newCallable = bind(callable, arg_list);
	当我们调用newCallable时，newCallable会调用callable，并传递给它arg_list中的参数。
	arg_list中的参数可能包含如_n的名字，其中n是一个整数。这些参数时“占位符”，表示newCallable的参数，
	它们占据了传递给newCallable的参数的“位置”。
25. 名字_n都定义在一个名为placeholders的命名空间中，而这个命名空间本身定义在std命名空间中。
26. 默认情况下，bind的那些不是占位符的参数被拷贝到bind返回的可调用对象中。但是，与lambda类似，有时对
	有些绑定的参数我们希望用引用方式传递，或是要绑定的参数的类型无法拷贝（ostream）。可以通过使用标准库
	ref函数，函数ref返回一个对象，包含给定的引用，此对象是可以拷贝的。标准库中还有一个cref函数，生成一个
	保存const应用的类。
27. 除了为每个容器定义的迭代器之外，标准库在头文件iterator中还定义了额外几种迭代器。这些迭代器包括以下几种。
	・插入迭代器（insert iterator）：这些迭代器被绑定到一个容器上，可用来向容器插入元素。
	・流迭代器（stream iterator）：这些迭代器被绑定到输入或输出流上，可用来遍历所关联的IO流。
	・反向迭代器（reverse iterator）：这些迭代器向后而不是向前移动。除了forward_list之外的标准库容器都有反向迭代器。
	・移动迭代器（move iterator）：这些专用的迭代器不是拷贝其中的元素，而是移动它们。
28. 插入器有三种类型，差异在于元素插入的位置：
	(1) back_inserter：创建一个使用push_back的迭代器。
	(2) front_inserter：创建一个使用push_front的迭代器。
	(3) inserter：创建一个使用insert的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的
	    迭代器。元素将被插入到给定迭代器所表示的元素之前。
29. 虽然iostream类型不是容器，但标准库定义了可以用于这些IO类型对象的迭代器。istream_iterator读取输入流，
    ostream_iterator向一个输入流写数据。
30. istream_iterator操作
	------------------------------------------------------------------------------------------------
										istream_iterator 操作
	------------------------------------------------------------------------------------------------
	istream_iterator<T> in(is);            in从输入流is读取类型为T的值
	istream_iterator<T> end;			   读取类型为T的值的istream_iterator迭代器，表示尾后位置
	in1 == in2		in1和in2必须读取相同类型。如果它们都是尾后迭代器，或绑定到相同的输入，则两者相等
	*in				返回从流中读取的值
	in->mem			与(*in).mem的含义相同
	++in, in++		使用元素类型所定义的>>运算符从输入流中读取下一个值。与以往一样，前置版本返回一个
					指向递增后迭代器的引用，后置版本返回旧值
	------------------------------------------------------------------------------------------------
31. ostream_iterator操作
	------------------------------------------------------------------------------------------------
										ostream_iterator 操作
	------------------------------------------------------------------------------------------------
	ostream_iterator<T> out(os);		out将类型为T的值写到输入流os中
	ostream_iterator<T> out(os, d);		out将类型为T的值写到输入流os中，每个值后面都输出一个d。d指向
										一个空字符结尾的字符数组
	out = val			用<<运算符将val写入到out所绑定的ostream中。val的类型必须与out可写的类型兼容
	*out, ++out, out++  这些运算符是存在的，但不对out做任何事情。每个运算符都返回out
	------------------------------------------------------------------------------------------------
32. 我们可以为任何定义了输入运算符(>>)的类型创建istream_iterator对象。类似的，只要类型有输出运算符(<<)
    ，我们就可以为其定义ostream_iterator。
33. 除了forward_list之外，标准容器上的其他迭代器都既支持递增运算又支持递减运算。但是，流迭代器不支持
	递减运算，因为不可能在一个流中反向移动。因此，不可能从一个forward_list或一个流迭代器创建反向迭代器。
34. 我们可以通过调用reverse_iterator的base成员函数来返回其对应的普通迭代器。
35. 任何算法的最基本的特性是它要求其迭代器提供哪些操作。算法所要求的迭代器操作可以分为5个迭代器类别
	(iterator category)。每个算法都会对它的每个迭代器参数指明须提供哪类迭代器。
	------------------------------------------------------------------------------------------------
											迭代器类别
	------------------------------------------------------------------------------------------------
	输入迭代器						只读，不写；单遍扫描，只能递增
	输出迭代器						只写，不读；单遍扫描，只能递增
	前向迭代器						可读写；多遍扫描，只能递增
	双向迭代器						可读写；多遍扫描，可递增递减
	随机访问迭代器					可读写，多遍扫描，支持全部迭代器运算
	------------------------------------------------------------------------------------------------
36. 对于向一个算法传递错误类别的迭代器的问题，很多编译器不会给出任何警告或提示。
37. 在任何其它算法分类之上，还有一组参数规范。大多数算法具有如下4种形式之一：
	alg(beg, end, other args);
	alg(beg, end, dest, other args);
	alg(beg, end, beg2, other args);
	alg(beg, end, beg2, end2, other args);
38. 算法命名规范
    (1) 一些算法使用重载形式传递一个谓词
		接受谓词参数来代替<或==运算符的算法，以及那些不接受额外参数的算法，通常都是重载的函数。
		unique(beg, end);			// 使用 == 运算符比较元素
		unique(beg, end, comp);     // 使用comp比较元素
	(2) _if版本的算法
		接受一个元素值的算法通常有另一个不同名的（不是重载的）版本，该版本接受一个谓词代替元素值。接受
		谓词参数的算法都有附加的_if前缀：
		find(beg, end, val);		// 查找输入范围中val第一次出现的位置
		find_if(beg, end, pred);    // 查找第一个令pred为真的元素
	(3) 区分拷贝元素的版本和不拷贝的版本
		默认情况下，重排元素的算法将重排后的元素写回给定的输入序列中。这些算法还提供另一个版本，将元素
		写到一个指定的输出目的位置。如我们所见，写到额外目的空间的算法都在名称候命附加一个_copy：
		reverse(beg, end);          // 反转输入范围中元素的顺序
		reverse_copy(beg, end, dest);    // 将元素按逆序拷贝到dest
		一些算法同时提供_copy和_if版本。这些版本接受一个目的位置迭代器和一个谓词：
		remove_if(v1.begin(), v1.end(), [](int i){return i % 2;});      // 从v1中删除奇数元素
		// 将偶数元素从v1拷贝到v2；v1不变
		remove_copy_if(v1.begin(), v1.end(), back_inserter(v2), [](int i){return i % 2; });
39. 与其他容器不同，链表类型list和forward_list定义了几个成员函数形式的算法，特别是，它们定义了独有的
    sort、merge、remove、reverse和unique。通用版本的sort要求随机访问迭代器，因此不能用于list和forward_list，
	因为这两个类型分别提供双向迭代器和前向迭代器。
	链表类型定义的其他算法的通用版本可以用于链表，但代价太高。这些算法需要交换输入序列中的元素。一个链表
	可以通过改变元素间的链接而不是真的交换它们的值来快速“交换”元素。因此，这些链表版本的算法的性能比
	对应的通用版本好得多。
    ------------------------------------------------------------------------------------------------
								list和forward_list成员函数版本的算法
    ------------------------------------------------------------------------------------------------
	这些操作都返回void
	lst.merge(1st2)			将来自lst2的元素合并入lst。lst和lst2都必须是有序的。元素将从lst2中删除。
	lst.merge(lst2, comp)   在合并之后，lst2变为空。第一个版本使用<运算符；第二个版本使用给定的比较
							操作。
	lst.remove(val)			调用erase删除掉给定值相等(==)或令-元谓词为真的每个元素
	lst.remove_if(pred)
	lst.reverse()			反转lst中元素的顺序
	lst.sort()				使用<或给定比较操作排序元素
	lst.sort(comp)
	lst.unique()			调用erase删除同一个值的连续拷贝。第一个版本使用==；第二个版本使用给定
	lst.unique(pred)		的二元谓词
	------------------------------------------------------------------------------------------------
40. 链表类型还定义了splice算法，此算法是链表数据结构所特有的，因此不需要通用版本。
	------------------------------------------------------------------------------------------------
							  list和forward_list的splice成员函数的参数
	------------------------------------------------------------------------------------------------
	lst.splice(args)或flst.splice_after(args)
	(p, lst2)			p是一个指向lst中元素的迭代器，或一个指向flst首前位置的迭代器。函数将lst2的
						所有元素移动到lst中p之前的位置或是flst中p之后的位置。将元素从lst2中删除。
						lst2的类型必须与lst或flst相同，且不能是同一个链表
	(p, lst2, p2)		p2是一个指向lst2中位置的有效的迭代器。将p2指向的元素移动到lst中，或将p2之后
						的元素移动到flst中。lst2可以是与lst或flst相同的链表
	(p, lst2, b, e)     b和e必须表示lst2中的合法范围。将给定范围中的元素从lst2移动到lst或flst。lst2
						与lst(或flst)可以是相同的链表，但p不能指向给定范围中元素
	------------------------------------------------------------------------------------------------
41. 多数链表特有的算法都与其通用版本很相似，但不完全相同。链表特有版本与通用版本间的一个至关重要的区别
	是链表版本会改变底层的容器。
*/
