#pragma once
/*
1.控制内存的分配
    某些应用程序对内存分配有特殊的需求，因此我们无法将标准内存管理机制直接应用于这些程序。它们常常需要自定义内存分配的细节，比如使用关键字new将对象放置在特定的内存空间中。为了实现
  这一目的，应用程序需要重载new运算符和delete运算符以控制内存分配的过程。
  1）重载new和delete
      尽管我们说能够“重载new和delete”，但是实际上重载这两个运算符与重载其他运算符的过程大不相同。要想真正掌握重载new和delete的方法，首先要对new表达式和delete表达式的工作机制有更多了解。
      当我们使用一条new表达式时：
      // new表达式
      string *sp = new string("a value");       // 分配并初始化一个string对象
      string *arr = new string[10];             // 分配10个默认初始化的string对象
    实际执行了三步操作。第一步，new表达式调用一个名为operator new（或者operator new[]）的标准库函数。该函数分配一块足够大的、原始的、未命名的内存空间以便存储特定类型的对象（或者对象的数组）。
                        第二步，编译器运行相应的构造函数以构造这些对象，并为其传入初始值。
                        第三步，对象被分配了空间并构造完成，返回一个指向该对象的指针。
      // delete表达式
      当我们使用一条delete表达式删除一个动态分配的对象时：
      delete sp;            // 销毁* sp，然后释放sp指向的内存空间
      delete [] arr;        // 销毁数组中的元素，然后释放对应的内存空间
    实际上执行了两步操作。第一步，对sp所指的对象或者arr所指的数组中的元素执行对应的析构函数。
                          第二步，编译器调用名为operator delete（或者operator delete[]）的标准库函数释放内存空间。
      如果应用程序希望控制内存分配的过程，则它们需要定义自己的operator new函数和operator delete函数。即使在标准库中已经存在这两个函数的定义，我们仍旧可以定义自己的版本。编译器不会对这种
    重复的定义提出异议，相反，编译器将使用我们自定义的版本替换标准库定义的版本。
      应用程序可以在全局作用域中定义operator new函数和operator delete函数，也可以将他们定义为成员函数。当编译器发现一条new表达式或delete表达式后，将在程序中查找可提供调用的operator函数。
  2）标准库定义了operator new函数和operator delete函数的8个重载版本。其中前4个版本可能抛出bad_alloc异常，后4个版本则不会抛出异常：
      // 这些版本可能抛出异常
      void *operator new(size_t);                   // 分配一个对象
      void *operator new[](size_t);                 // 分配一个数组
      void *operator delete(void*) noexcept;        // 释放一个对象
      void *operator delete[](void*) noexcept;      // 释放一个数组

      // 这些版本可能抛出异常
      void *operator new(size_t, nothrow_t&);                   // 分配一个对象
      void *operator new[](size_t, nothrow_t&);                 // 分配一个数组
      void *operator delete(void*, nothrow_t&) noexcept;        // 释放一个对象
      void *operator delete[](void*, nothrow_t&) noexcept;      // 释放一个数组
      类型nothrow_t是定义在new头文件中的一个struct，在这个类型中不包含任何成员。new头文件还定义了一个名为nothrow的const对象，用户可以通过这个对象请求new的非抛出版本。
      应用程序可以自定义上面函数版本中的任意一个，前提是自定义的版本必须位于全局作用域或者类作用域中。当我们将上述运算符函数定义成类的成员时，它们是隐式静态的。我们无须
    显式地声明static，当然这么做也不会引发错误。因为operator new用在对象构造之前而operator delete用在对象销毁之后，所以这两个成员（new和delete）必须是静态的，而且它们
    不能操纵类的任何数据成员。
      对于operator new函数或者operator new[]函数来说，它的返回类型必须是void*，第一个形参的类型必须是size_t且该形参不能含有默认实参。尽管在一般情况下我们可以自定义具有任何
    形参的operator new，但是下面这个函数却无论如何不能被用户重载：
        void *operator new(size_t, void*);          // 不允许重定义这个版本
        这种形式只供标准库使用。不能被用户重新定义。
  3）定位new表达式
      尽管operator new函数和operator delete函数一般用于new表达式，然而它们毕竟是标准库的两个普通函数，因此普通的代码也可以直接调用它们。
      应用程序如果想把内存分配与初始化分离开来的话，需要调用operator new和operator delete。它们负责分配或释放内存空间，但是不会构造或销毁对象。
      对于operator new分配的内存空间来说，我们应该使用new的定位new（placement new）形式构造对象。如我们所知，new的这种形式为分配函数提供了额外的信息。我们可以使用定位new
    传递一个地址，此时定位new的形式如下所示：
        new (place_address) type
        new (place_address) type (initializers)
        new (place_address) type [size]
        new (place_address) type [size] { braced initializer list }
      其中place_address必须是一个指针，同时在initializers中提供一个（可能为空的）以逗号分隔的初始化列表，该初始值列表将用于构造新分配的对象。
      事实上，定位new允许我们在一个特定的、预先分配的内存地址上构造对象。
      传递给定位new的指针无须指向operator new分配的内存。实际上，传递定位new表达式的指针甚至不需要指向动态内存。
      我们既可以通过对象调用析构函数，也可以通过对象的指针或引用调用析构函数，这与调用其他成员函数没有什么区别：
        string *sp = new string("a value");     // 分配并初始化一个string对象
        sp->~string();
      调用析构函数可以清楚给定的对象但是不会释放该对象所在的空间。如果需要的话，我们可以重新使用该空间。
2.运行时类型识别
      运行时类型识别（run-time type identification, RTTI）的功能由两个运算符实现：
      ・typeid运算符，用于返回表达式的类型。
      ・dynamic_case运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用。
      当我们将这两个运算符用于某种类型的指针或引用，并且该类型含有虚函数时，运算符将使用指针或引用所绑定对象的动态类型。
      这两个运算符特别适用于以下情况：我们想使用基类对象的指针或引用执行某个派生类操作并且该操作不是虚函数。
  1）dynamic_cast运算符
      dynamic_cast运算符（dynamic_cast operator）的使用形式如下所示：
        dynamic_cast<type*>(e)
        dynamic_cast<type&>(e)
        dynamic_cast<type&&>(e)
      一种，type必须是一个类类型，并且通常情况下该类型应该含有虚函数。在第一种形式中，e必须是一个有效的指针；在第二种形式中，e必须是一个左值；在第三种形式中，e不能是左值。
      在上面的所有形式中，e的类型必须符合以下三个条件中的任意一个：e的类型是目标type的公有派生类、e的类型时目标type的公有基类或者e的类型就是目标type的类型。如果符合，则
    类型转换可以成功。否则，转换失败。如果一条dynamic_cast语句的转换目标是指针类型并且失败了，则结果为0.如果转换目标是引用类型并且失败了，则dynamic_cast运算符将抛出一个
    bad_cast异常。
  2）typeid运算符
      typeid表达式的形式是typeid(e)，其中e可以是任意表达式或类型的名字。typeid操作的结果是一个常量对象的引用，该对象的类型是标准库类型type_info或者type_info的公有派生类型。
    type_info类定义在typeinfo头文件中。
      typeid运算符可以作用于任意类型的表达式。和往常一样，顶层const被忽略，如果表达式是一个引用，则typeid返回引用所引对象的类型。不过当typeid作用于数组或函数时，并不会执行
    向指针的标准类型转换。
      当运算对象不属于类类型或者是一个不包含任何虚函数的类时，typeid运算符指示的是运算对象的静态类型。而当运算对象是定义了至少一个虚函数的类的左值时，typeid的结果直到运行
    时才会得到。
      通常情况下，我们使用typeid比较两条表达式的类型是否相同，或者比较一条表达式的类型是否与指定类型相同。
      当typeid作用于指针时（而非指针所指的对象），返回的结果是该指针的静态编译时类型。typeid是否需要运行时检查决定了表达式是否会被求值。
  3）typeinfo类
      type_info类的精确定义随着编译器的不同而略有差异。不过，C++标准规定type_info类必须定义在typeinfo头文件中，并且至少提供以下所列的操作：
      ----------------------------------------------------------------------------------------------------------------------------------
                                                            type_info的操作
      ----------------------------------------------------------------------------------------------------------------------------------
        t1 == t2        如果type_info对象t1和t2表示同一种类型，返回true；否则返回false
        t1 != t2        如果type_info对象t1和t2表示不同的类型，返回true；否则返回false
        t.name()        返回一个C风格字符串，表示类型名字的可打印形式。类型名字的生成方式因系统而已
        t1.before(t2)   返回一个bool值，表示t1是否位于t2之前。before所采用的顺序关系是依赖于编译器的
      ----------------------------------------------------------------------------------------------------------------------------------
      除此之外，因为type_info类一般是作为一个基类出现，所以它还应该提供一个公有的虚析构函数。当编译器希望提供额外的类型信息时，通常在type_info的派生类中完成。
      type_info类没有默认构造函数，而且它的拷贝和移动构造函数以及赋值运算符都被定义成删除的。因此，我们无法定义或者拷贝type_info类型的对象，也不能为type_info
    类型的对象赋值。创建type_info对象的唯一途径是使用typeif运算符。
3.枚举类型
    枚举类型（enumeration）使我们可以将一组整形常量组织在一起。和类一样，每个枚举类型定义了一种新的类型。枚举属于字面值常量类型。
  1）C++包含两种枚举：
      限定作用域的枚举类型（scoped enumberation）：C++11新标准引入。定义限定作用域的枚举类型的一般形式是：首先是关键字enum class（或者等价地使用enum struct），
    随后是枚举类型名字以及用花括号括起来的以逗号分隔的枚举成员（enumerator）列表，最后是一个分号：
        enum class open_modes { input, output, append };
      不限定作用域的枚举类型（unscoped enumeration）时省略掉关键字class（或struct），枚举类型的名字是可选的：
        enum color { red, yellow, green};                               // 不限定作用域的枚举类型
        enum {floatPrec = 6; doublePrec = 10, double_doublePrec = 10};  // 未命名、不限定作用域的枚举类型
  2）在限定作用域的枚举类型中，枚举成员的名字遵循常规的作用域准则，并且在枚举类型的作用域外是不可访问的。与之相反，在不限定作用域的枚举类型中，枚举成员的作用域
    与枚举类型本身的作用域相同。
  3）默认情况下，枚举值从0开始，依次加1。不过我们也能为一个或几个枚举成员指定专门的值：
        enum class intTypes{
            charTyp = 8, shortTyp = 16, intTyp = 16,
            longTyp = 32, long_longTyp = 64
        };
     由枚举成员intTyp和shortTyp可知，枚举值不一定唯一。如果我们没有显示地提供初始值，则当前枚举成员的值等于之前枚举成员的值加1。
  4）枚举成员是const，因此在初始化枚举成员时提供的初始化值必须是常量表达式。
  5）要想初始化enum对象或者为enum对象赋值，必须使用该类型的一个枚举成员或者该类型的另一个对象。
  6）一个不限定作用域的枚举类型的对象或枚举成员自动地转换成整形。
  7）尽管每个enum都定义了唯一的类型，但实际上enum是由某种整数类型表示的。在C++11新标准中，我们可以在enum的名字后加上冒号以及我们想在该enum中使用的类型：
        enum intValues: unsigned long long{
            charTyp = 255, shortTyp = 65535, intTyp = 65535,
            longTyp = 629496744073709551615ULL
        };
     如果我们没有指定enum的潜在类型，则默认情况下限定作用域的enum成员类型是int。对于不限定作用域的枚举类型来说，其枚举成员不存在默认类型，我们只知道成员的
    潜在类型足够大，肯定能够容纳枚举值。如果我们指定了枚举成员的潜在类型（包括对限定作用域的enum的隐式指定），则一旦某个枚举成员的值超出了该类型所能容纳的
    范围，将引发程序错误。
  8）在C++11新标准中，我们可以提前声明enum。enum的前置声明（无论隐式地还是显式地）必须指定其成员的大小：
        // 不限定作用域的枚举类型intValues的前置声明
        enum intValues: unsigned long long;             // 不限定作用域的，必须指定成员类型
        enum class opoen_modes;                         // 限定作用域的枚举类型可以使用默认成员类型int
  9）尽管我们不能直接将整形值传递给enum形参，但是可以将一个不限定作用域的枚举类型的对象或枚举成员传给整形形参。此时，enum的值提升成int或更大的整形，实际提升
    的结果由枚举类型的潜在类型决定。尤其是，枚举成员永远不会提升成unsigned char, 即使枚举值可以用unsigned char存储也是如此。
4.类成员指针
     成员指针（pointer to member）是指可以指向类的非静态成员的指针。一般情况下，指针指向一个对象，但是成员指针指示的是类的成员，而非类的对象。
     成员指针的类型囊括了类的类型以及成员的类型。当初始化一个这样的指针时，我们令其指向类的某个成员，但是不指定该成员所属的对象；直到使用成员指针时，才提供成员
    所属的对象。
    1）和其他指针一样，在声明成员指针时我们也使用*来表示当前声明的名字是一个指针。与普通指针不同的是，成员指针还必须包含成员所属的类。因此，我们必须在*之前添加
      classname::以表示当前定义的指针可以指向classname的成员。例如：
        // pdata可以指向一个常量（非常量）Screen对象的string成员
        const string Screen::*pdata;
       当我们初始化一个成员指针（或者向它赋值）时，需指定它所指的成员。例如，我们可以令pdata指向某个非特定Screen对象的contents成员：
        pdata = &Screen::contents;
       当然，在C++11新标准中声明成员指针最简单的方法是使用auto或decltype:
        auto pdata = &Screen::contents;
    2）读者必须清楚的一点是，当我们初始化一个成员指针或为成员指针赋值时，该指针并没有指向任何数据。成员指针指定了成员而非该成员所属的对象，只有当解引用成员指针时
      我们才提供对象的信息。
       与成员访问运算符.和->类似，也有两种成员指针访问运算符：.*和->*，这两个运算符使得我们可以解引用指针并获得该对象的成员：
        Screen myScreen，*pScreen = &myScreen;
        // .*解引用pdata以获得myScreen对象的contents成员
        auto s = myScreen.*pdata;
        // ->*解引用pdata以获得pScreen所指对象的contents成员
        s = pScreen->*pdata;
    3）类似于任何其他函数指针，指向成员函数的指针也需要指定目标函数的返回类型和形参类型。如果成员函数时const成员或者引用成员，则我们必须将const限定符或引用限定符包含进来。
        char (Screen::*pmf2)(Screen::pos, Screen::pos) const;
        pmf2 = &Screen::get;
       和普通函数指针不同的是，在成员函数和指向该成员的指针之间不存在自动转换规则：
        pmf = &Screen::get;         // 必须显式地使用取地址运算符
        pmf = Screen::get;          // 错误：在成员函数和指针之间不存在自动转换规则
    4）使用类型别名或typedef可以让成员指针更容易理解。
       例如：
        using Action = char (Screen::*)(Screen::pos, Screen::pos) const;
        Action get = &Screen::get;  // get指向Screen的get成员
    5）与普通的函数指针不同，成员指针不是一个可调用对象，这样的指针不支持函数调用运算符。以为成员指针不是可调用对象，所以我们不能直接将一个指向成员函数的指针传递给算法。
    6）使用function生成一个可调用对象
        从指向成员函数的指针获取可调用对象的一种方法是使用标准库模板function：
         function<bool (const string&)> fcn = &string::empty;
         find_if(svec.begin(), svec.end(), fcn);
    7）使用mem_fn生成一个可调用对象
        通过使用标准库功能mem_fn来让编译器负责推断成员的类型。和function一样，mem_fn也定义在functional头文件中，并且可以从成员指针生成一个可调用对象；和function不同的是，
       mem_fn可以根据成员指针的类型推断可调用对象的类型，而无需用户显式地指定：
        find_if(svec.begin(), svec.end(), mem_fn(&string::empty));
    8）使用bind生成一个可调用对象
        出于完整性的考虑，我们还可以使用bind从成员函数生成一个可调用对象：
         // 选择范围中的每个string，并将其bind到empty的第一个隐式实参上
         auto it = find_if(svec.begin(), svec.end(), bind(&string::empty, _1));
5.嵌套类
    1）一个类可以定义在两一个类的内部，前者称为嵌套类（nested class）或嵌套类型（nested type）。嵌套类常用于定义作为实现部分的类。
    2）嵌套类是一个独立的类，与外层类基本没什么关系。特别是，外层类的对象和嵌套类的对象时相互独立的。
    3）嵌套类的名字在外层类作用域中是可见的，在外层类作用域之外不可见。
    4）外层类对嵌套类的成员没有特殊的访问权限，同样，嵌套类对外层类的成员也没有特殊的访问权限。
    5）嵌套类在外层类中定义了一个类型成员。和其他成员类似，该类型的访问权限由外层类决定。
    6）和成员函数一样，嵌套类必须声明在类的内部，但是可以定义在类的内部或者外部。在嵌套类在外层类之外完成真正的定义之前，它都是一个不完全类型。
6.union: 一种节省空间的类
      联合（union）是一种特殊的类。一个union可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当我们给union的某个成员赋值之后，该union的其他成员就变成未定义的
    状态了。分配给一个union对象的存储空间至少要能容纳它的最大的数据成员。和其他类一样，一个union定义了一种新类型。
      类的某些特征对union同样适用，但并非所有特性都如此。union不能含有引用类型的成员，除此之外，它的成员可以是绝大多数类型。在C++11新标准中，含有构造函数或析构函数的类类型
    也可以作为union的成员类型。union可以为其成员指定public、protected和private等保护标记。默认情况下，union的成员都是公有的，这一点与struct相同。
      union可以定义包括构造函数和析构函数在内的成员函数。但是由于union既不能继承自其他类，也不能作为基类使用，所以在union中不能含有虚函数。
    1）union提供了一种有效的途径使得我们可以方便地表示一组类型不同的互斥值。例如：
        // Token类型的对象只有一个成员，该成员的类型可能是下列类型中的任意一种
        union Token{
            // 默认情况下成员是公有的
            char cval;
            int ival;
            double dval;
        };
    2）匿名union（anonymous union）是一个未命名的union，并且在右花括号和分号之前没有任何声明。一旦我们定义了一个匿名union，编译器就自动地为该union创建一个未命名的对象：
        union{
            char cval;
            int ival;
            double dval;
        };  // 定义一个未命名的对象，我们可以直接访问它的成员
        cval = 'c';
        ival = 42;
       匿名union不能包含受保护的成员或私有成员，也不能定义成员函数。
    3）对于union来说，要想构造或销毁类类型的成员必须执行非常复杂的操作，因此我们通常把含有类类型成员的union内嵌在另一个类当中。这个类可以管理并控制与union的类类型成员
      有关的状态转换。为了追踪union中到底存储了什么类型的值，我们通常会定义一个独立的对象，该对象称为union的判别式（discriminant）。我们可以使用判别式辨认union存储的值。
7.局部类
    类可以定义在某个函数的内部，我们称这样的类为局部类（local class）。局部类定义的类型只在定义它的作用域内可见。和嵌套类不同，局部类的成员受到严格限制。
    1）局部类的所有成员（包括函数在内）都必须完整定义在类的内部。因此，局部类的作用与嵌套类相比相差很远。基于其特性，局部类的成员函数的复杂性不可能太高。类似的，在局部类中
      也不允许声明静态数据成员，因为我们没法定义这样的成员。
    2）局部类对其外层作用域中名字的访问权限受到很多限制，局部类只能访问外层作用域定义的类类型、静态类型以及枚举成员。如果局部类定义在某个函数内部，则该函数的普通局部变量不能
      被该局部类使用。
    3）外层函数对局部类的私有成员没有任何访问权限。当然，局部类可以将外层函数声明为友元；或者更常见的情况是局部类将其成员声明成公有的。
    4）可以在局部类的内部再嵌套一个类。此时，嵌套类的定义可以出现在局部类之外。不过，嵌套类必须定义在与局部类相同的作用域中。局部类内的嵌套类也是一个局部类，必须遵循局部类的
      各种规定。嵌套类的所有成员都必须定义在嵌套类内部。
8.固有的不可移植的特性
    为了支持底层编程，C++定义了一些固有的不可移植（nonportable）的特性。所谓不可移植的特性是指因机器而异的特性，当我们将含有不可移植特性的程序从一台机器专业到另一台机器上时，
   通常需要重新编写该程序。
    1）位域
        类可以将其（非静态）数据成员定义成位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。位域在内存中
      的布局是与机器相关的。
    2）位域的类型必须是整形或枚举类型。因为带符号位域的行为是由具体实现确定的，所以在通常情况下我们使用无符号类型保存一个位域。位域的声明形式是在成员之后紧跟一个冒号以及一个
      常量表达式，该表达式用于指定成员所占的二进制位数：
            typedef unsigned int Bit;
            class File{
                Bit mode: 2;    // mode占2位
                public:
            };
    3）如果可能的话，在类的内部连续定义的位域压缩在同一整数的相邻位，从而提供存储压缩。这些二进制是否能压缩到一个整数中以及如何压缩是与机器相关的。
    4）取地址运算符（&）不能作用于位域，因此任何指针都无法指向类的位域。
    5）通常使用内置的位运算符操作超过1位的位域。
    6）如果一个类定义了位域成员，则它通常也会定义一组内联的成员函数以检验或设置位域的值。
    7）volatile限定符
        volatile的确切含义与机器有关，只能通过阅读编译器文档来理解。要想让使用了volatile的程序在移植到新机器或新编译器后仍然有效，通常需要对该程序进行某些改变。
    8）直接处理硬件的程序常常包含这样的数据元素，他们的值由程序直接控制之外的过程控制。例如，程序可能包含一个由系统时钟定时更新的变量。当对象的值可能在程序的控制或检测之外被
      改变时，应该将该对象声明为volatile。关键字volatile告诉编译器不应该对这样的对象进行优化。
    9）只有volatile的成员函数才能被volatile的对象调用。
    10）我们可以声明volatile指针、指向volatile对象的指针以及指向volatile对象的volatile指针。
    11）const和volatile的一个重要区别是我们不能使用合成的拷贝/移动构造函数及赋值运算符初始化volatile对象或从volatile对象赋值。合成的成员接受的形参类型是（非volatile）常量引用，
      显然我们不能把一个非volatile引用绑定到一个volatile对象上。如果一个类希望拷贝、移动或赋值它的volatile对象，则该类必须自定义拷贝或移动操作。
    12）链接指示：extern "C"
        C++程序有时需要调用其他语言编写的函数，最常见的是调用C语言编写的函数。像所有其他名字一样，其他语言中的函数名字也必须在C++中进行声明，并且该声明必须指定返回类型和形参列表。
      对于其他语言编写的函数来说，编译器检查其调用的方式与处理普通C++函数的方式相同，但是生成的代码有所区别。C++使用链接指示（linkage directive）指出任意非C++函数所用的语言。
    13）要想把C++代码和其他语言（包括C语言）编写的代码放在一起使用，要求我们必须有权访问该语言的编译器，并且这个编译器与当前的C++编译器是兼容的。
    14）链接指示可以有两种形式：单个的或复合的。链接指示不能出现在类定义或函数定义的内部。同样的链接指示必须在函数的每个声明中都出现。
        举个例子，接下来声明显示了cstring头文件的某些C函数是如何声明的：
        // 单语句链接指示
        extern "C" size_t strlen(const char *);
        // 复合语句链接指示
        extern "C" {
            int strcmp(const char*, const char*);
            char *strcat(char*, const char*);
        }
        其中的字面值常量指出了编写函数所用的语言。编译器应该支持对C语言的链接指示。此外，编译器也可能会支持其他语言的链接指示，如extern "Ada"、extern "FORTRAN"等。
    15）链接指示可以嵌套，因此如果多重声明的形式应用于整个头文件，且头文件包含带自带链接指示的函数，则该函数的链接不受影响。
    16）C++从C语言继承的标准库函数可以定义成C函数，但并非必须：决定使用C还是C++实现C标准库，是每个C++实现的事情。
    17）编写函数所用的语言是函数类型的一部分。因此，对于使用链接指示定义的函数来说，它的每个声明都必须使用相同的链接指示。而且，指向其他语言编写的函数的指针必须与函数本身使用相同的链接指示。
    18）当我们使用链接指示时，它不仅对函数有效，而且对作为返回类型或形参类型的函数指针也有效：
    19）因为链接指示同时作用于声明语句中的所有函数，所以如果我们希望给C++函数传入一个指向C函数的指针，则必须使用类型别名：
            // FC是一个指向C函数的指针
            extern "C" typedef void FC(int);
            // f2是一个C++函数，该函数的形参是指向C函数的指针
            void f2(FC *);
    20）导出C++函数到其他语言
        通过使用链接指示对函数进行定义，我们可以另一个C++函数在其他语言编写的程序中可用：
        // calc函数可以被C程序调用
        extern "C" double calc(double dparm) { ... }
      编译器将为该函数生成适合于指定语言的代码。
    21）值得注意的是，可被多种语言共享的函数的返回类型或形参类型受到很多限制。例如，我们不太可能把一个C++类的对象传给C程序。
    22）有时需要在C和C++中编译同一个源文件，为了实现这一目的，在编译C++版本的程序时预处理器定义__cplusplus（两个下划线）。利用这个变量，我们可以在编译C++程序的时候
      有条件地包含进来一些代码：
            #ifdef __cplusplus
            // 正确：我们正在编译C++程序
            extern "C"
            endif
            int strcmp(const char*, const char*);
    23）链接指示与重载函数的相互作用依赖于目标语言。如果目标语言支持重载函数，则为该语言实现链接指示的编译器很可能也支持重载这些C++的函数。
        C语言不支持函数重载，因此也就不难理解为什么一个C链接指示只能用于说明一组重载函数中的某一个了。
        如果在一组重载函数中有一个是C函数，则其余的必定都是C++函数。
*/